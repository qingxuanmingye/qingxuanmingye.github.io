<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="CRIST兴趣使然" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="CRIST兴趣使然">
<meta property="og:url" content="https://qingxuanmingye.github.io/index.html">
<meta property="og:site_name" content="CRIST兴趣使然">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CRIST兴趣使然">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://qingxuanmingye.github.io/">





  <title>CRIST兴趣使然</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/qingxuanmingye" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CRIST兴趣使然</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">采庶子之春华，忘家丞之秋实　</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/05/01/leetcode-回溯算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/01/leetcode-回溯算法/" itemprop="url">leetcode-回溯算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-01T15:22:09+08:00">
                2019-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法专题/" itemprop="url" rel="index">
                    <span itemprop="name">算法专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/05/01/leetcode-日卡一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/01/leetcode-日卡一/" itemprop="url">leetcode-日卡一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-01T12:46:14+08:00">
                2019-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软柿子专场/" itemprop="url" rel="index">
                    <span itemprop="name">软柿子专场</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  723 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>菜     <a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a>（Dx）<a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 报数</a>（B-）<a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a>（D）<a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a>（D+）<a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a>（Dx）<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a>（Dx）</li>
<li>中</li>
<li>危</li>
</ul>
<p>总结：本来想捏的软柿子。结果发现，被柿子给捏了。</p>
<hr>
<h4 id="326-3的幂（Dx）"><a href="#326-3的幂（Dx）" class="headerlink" title="326. 3的幂（Dx）"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a>（Dx）</h4><p>分析：妙解。用数论的知识：3的幂次的质因子只有3.</p>
<p>输入时int型，正数范围0~2^31. 即最大的数为3^19 = 1162261467  只需要看这个数是否能被n整除即可。</p>
<blockquote>
<p>质因子（或质因数）在数论里是指能整除给定正整数的质数。根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。两个没有共同质因子的正整数称为互质。因为1没有质因子，1与任何正整数（包括1本身）都是互质。只有一个质因子的正整数为质数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">1162261467</span> % n == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="38-报数（B-）"><a href="#38-报数（B-）" class="headerlink" title="38. 报数（B-）"></a><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 报数</a>（B-）</h4><p>分析：？什么情况，菜鸟难度的题，题意看了半天。我是来虐菜的，不是来被虐的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        b = <span class="string">'1'</span>  <span class="comment">#将第一行的1换成字符类型，便于下一行的读出</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>): <span class="comment">#(n-1)是因为第一行不需要处理，直接可以读出</span></span><br><span class="line">            </span><br><span class="line">            a, c, count = b[<span class="number">0</span>], <span class="string">''</span>, <span class="number">0</span>             </span><br><span class="line">            <span class="comment">#a用来读取上一行的第一个字符，c用来存放读出的内容(char)，count用来统计</span></span><br><span class="line">           </span><br><span class="line">        	<span class="keyword">for</span> j <span class="keyword">in</span> b:</span><br><span class="line">                <span class="keyword">if</span> a == j:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c += str(count) + a   <span class="comment">#注意一定要将count转换为字符型，否则两个数就会相加</span></span><br><span class="line">                    a = j</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            c += str(count) + a</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h4 id="58-最后一个单词的长度（D）"><a href="#58-最后一个单词的长度（D）" class="headerlink" title="58. 最后一个单词的长度（D）"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a>（D）</h4><p>分析：蛮简单的一道题，知道长度就可以从后往前遍历了。注意空集存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt, tail = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tail &gt;= <span class="number">0</span> <span class="keyword">and</span> s[tail] == <span class="string">' '</span>:  <span class="comment">#去掉末尾空格，再计数。</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tail &gt;= <span class="number">0</span> <span class="keyword">and</span> s[tail] != <span class="string">' '</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h4 id="66-加一（D-）"><a href="#66-加一（D-）" class="headerlink" title="66. 加一（D+）"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a>（D+）</h4><p>分析：短小不错的一道题。</p>
<p>精简版，把数列直接拼接成数字，加一之后再转化为数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        num = str(int(<span class="string">''</span>.join([str(a) <span class="keyword">for</span> a <span class="keyword">in</span> digits])) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> num]</span><br></pre></td></tr></table></figure>
<p>常规做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(digits):</span><br><span class="line">            <span class="keyword">if</span> digits[i] + flag == <span class="number">10</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += flag</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">            digits.append(<span class="number">1</span>)</span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
<h4 id="67-二进制求和（Dx）"><a href="#67-二进制求和（Dx）" class="headerlink" title="67. 二进制求和（Dx）"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a>（Dx）</h4><p>巧妙的做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> bin(int(a,<span class="number">2</span>) + int(b,<span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
<h4 id="69-x-的平方根（Dx）"><a href="#69-x-的平方根（Dx）" class="headerlink" title="69. x 的平方根（Dx）"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a>（Dx）</h4><p>牛顿迭代法。求平方的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">while</span> r &gt; x / r:</span><br><span class="line">            r = (r + x / r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> int(r)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/28/leetcode-数组一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/leetcode-数组一/" itemprop="url">leetcode-数组一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T16:46:17+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/需二刷/" itemprop="url" rel="index">
                    <span itemprop="name">需二刷</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>菜    <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a>（D-）</li>
<li>中    <a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a>（B+）<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a>（B-）<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a>（C）<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a>（<strong>A-中二</strong>）    <a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a>（A-）</li>
<li>危    <a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a>（A-）</li>
</ul>
<p>总结：本来以为数组题很简单，结果碰到好多问题。引出回溯法，和堆排序。做个专题练习一下。任重道远啊，差的太多了。</p>
<hr>
<h4 id="31-下一个排列（B-）"><a href="#31-下一个排列（B-）" class="headerlink" title="31. 下一个排列（B+）"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a>（B+）</h4><p>分析：一道数组题竟然卡了好久。为什么没有思路呢。关键在于，题意理解，还有细化问题。倒叙从小到大，比较。找到前一个大于后一个，这时交换。再从后往前遍历，确保交换的是最小一个大于i-1的数。然后将i-1之后的所有数从小到大排序。也就是倒序。</p>
<p>转换思维一时间没有转换过来。感觉又误入歧途了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i<span class="number">-1</span> &gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(i,len(nums))):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                        nums[i<span class="number">-1</span>], nums[j] = nums[j], nums[i<span class="number">-1</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                nums[i:] = nums[i:][::<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums = nums.reverse()</span><br></pre></td></tr></table></figure>
<p>第二种。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, i<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                        nums[j], nums[i<span class="number">-1</span>] = nums[i<span class="number">-1</span>], nums[j]</span><br><span class="line">                        nums[i:] = list(reversed(nums[i:]))</span><br><span class="line">                        <span class="keyword">return</span>		<span class="comment">#稍微有点问题，题干说不返回return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)//<span class="number">2</span>):	<span class="comment">#优化只遍历一半，第一个与最后一个交换。</span></span><br><span class="line">            nums[i], nums[-i<span class="number">-1</span>] = nums[-i<span class="number">-1</span>], nums[i]</span><br></pre></td></tr></table></figure>
<h4 id="33-搜索旋转排序数组（B-）"><a href="#33-搜索旋转排序数组（B-）" class="headerlink" title="33. 搜索旋转排序数组（B-）"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a>（B-）</h4><p>分析：注意要求！你的算法时间复杂度必须是 <strong><em>O</em>(log <em>n</em>)</strong> 级别。想到二分法。</p>
<p>先膜拜一下大神的代码</p>
<blockquote>
<p>在用 <code>for..in..</code> 迭代对象时，如果对象没有实现 <code>__iter__</code> <code>__next__</code> 迭代器协议，Python的解释器就会去寻找<code>__getitem__</code> 来迭代对象，如果连<code>__getitem__</code> 都没有定义，这解释器就会报对象不是迭代器的错误.</p>
<p>实例调用__class__属性时会指向该实例对应的类，然后可以再去调用其它类属性，毕竟类属性还是由类调用会比较好</p>
<p>bisect 其目的在于查找该数值将会插入的位置并返回，而不会插入。</p>
<p> bisect_left 和 bisect_right 函数，该函数用入处理将会插入重复数值的情况，返回将会插入的位置：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        self.__class__.__getitem__ = <span class="keyword">lambda</span> self, m: <span class="keyword">not</span>(target &lt;nums[<span class="number">0</span>] &lt;= nums[m] <span class="keyword">or</span> nums[<span class="number">0</span>] &lt;= nums[m] &lt; target <span class="keyword">or</span> nums[m] &lt; target &lt;= nums[<span class="number">-1</span>])</span><br><span class="line">        i = bisect.bisect_left(self, <span class="literal">True</span>, <span class="number">0</span>, len(nums))</span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> target <span class="keyword">in</span> nums[i:i+<span class="number">1</span>] <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<p>一看到题目要求时间复杂度O(log n) 级别，就应该想到应该是用二分法了。但这题难就难在它并不是一个严格意义上的递增序列，而是两段递增序列组成的。那第一步就应该先用二分法找出分界点。然后对两段用二分法查找出index。相当于用了两次二分法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span>       </span><br><span class="line">        <span class="comment">#先找到两个第二个升序数组的第一项的</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[r]:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        pol = l</span><br><span class="line">        ans = self.binary_search(target, nums[:pol])</span><br><span class="line">        <span class="keyword">if</span> ans == <span class="number">-1</span>:</span><br><span class="line">            ans = self.binary_search(target, nums[pol:])</span><br><span class="line">            <span class="keyword">if</span> ans != <span class="number">-1</span>:</span><br><span class="line">                ans += len(nums[:pol])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 二分查找index值函数   </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(self, target, nums)</span>:</span></span><br><span class="line">        index = <span class="number">-1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = mid </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<p>第三种。直接对target位置进行细分比较。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> target == nums[r]:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            <span class="keyword">elif</span> target == nums[l]:</span><br><span class="line">                <span class="keyword">return</span> l</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; nums[r]:</span><br><span class="line">                    <span class="keyword">if</span> target &gt; nums[m] <span class="keyword">and</span> target &lt; nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[m] <span class="keyword">and</span> target &gt; nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置（C）"><a href="#34-在排序数组中查找元素的第一个和最后一个位置（C）" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置（C）"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a>（C）</h4><p>分析：你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>经过上一题的洗礼，这道题就显得简单很多了。先二分，找到元素。然后，往前往后循环找到第一个，和最后一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r-l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid <span class="number">-1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                l = mid</span><br><span class="line">                r = mid</span><br><span class="line">                <span class="keyword">while</span> l &gt; <span class="number">0</span> <span class="keyword">and</span> nums[l<span class="number">-1</span>] == nums[l]:</span><br><span class="line">                    l = l - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r &lt; len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[r] == nums[r+<span class="number">1</span>]:</span><br><span class="line">                    r = r + <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [l,r]</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="35-搜索插入位置（D-）"><a href="#35-搜索插入位置（D-）" class="headerlink" title="35. 搜索插入位置（D-）"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a>（D-）</h4><p>分析：很简单的一道题。二分法并没有快反而变慢了，大概是用例问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.append(target)</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br></pre></td></tr></table></figure>
<p>二分法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
<h4 id="39-组合总和（A-）中二"><a href="#39-组合总和（A-）中二" class="headerlink" title="39. 组合总和（A-）中二"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a>（A-）中二</h4><p>分析：想用dp做但是感觉不太对。看了别人的答案，觉得步骤很巧妙。这种自迭代加上过滤，匿名函数综合运用。有点厉害。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> candidates <span class="keyword">or</span> target &lt; min(candidates):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="comment"># 以下过滤器可避免出现排列不同的重复答案且免排序，x&gt;=i和x&lt;=i都行</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.combinationSum(list(filter(<span class="keyword">lambda</span> x: x &lt;= i, candidates)), target - i):</span><br><span class="line">                res.append([i] + j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
</blockquote>
<p>第二种。</p>
<p>分支界限法，使用递归函数做到自然剪枝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        mylist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)):</span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] == <span class="number">0</span>:</span><br><span class="line">                mylist.append([candidates[i]])</span><br><span class="line">            <span class="keyword">elif</span> target - candidates[i] &gt; <span class="number">0</span>:</span><br><span class="line">                result = self.combinationSum(candidates[i:], target - candidates[i])</span><br><span class="line">                <span class="keyword">if</span> result:</span><br><span class="line">                    <span class="keyword">for</span> ll <span class="keyword">in</span> result:</span><br><span class="line">                        ll.insert(<span class="number">0</span>, candidates[i])</span><br><span class="line">                    mylist += result</span><br><span class="line">        <span class="keyword">return</span> mylist</span><br></pre></td></tr></table></figure>
<p>第三种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        cand = sorted(candidates)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(remain, stack)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">                ans.append(stack)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> cand:</span><br><span class="line">                <span class="keyword">if</span> i &gt; remain:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; i:<span class="comment">#这个条件为了答案不重复</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dfs(remain - i, stack + [i])</span><br><span class="line">        dfs(target, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="40-组合总和-II（A-）"><a href="#40-组合总和-II（A-）" class="headerlink" title="40. 组合总和 II（A-）"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a>（A-）</h4><p>分析：和上一题差不多的方法。</p>
<p>回溯法。不是很清楚。明天开个专题。训练一下。答案贴出来，暂且不表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(candidates, target, [], [])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, tmp, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(tmp) == target <span class="keyword">and</span> sorted(tmp) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(sorted(tmp))</span><br><span class="line">        <span class="keyword">elif</span> sum(tmp) &lt; target:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)):</span><br><span class="line">                self.dfs(candidates[i + <span class="number">1</span>:], target, tmp + candidates[i:i + <span class="number">1</span>], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>第二种。用时短了不少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        len_nums = len(candidates)</span><br><span class="line">        self.X = []</span><br><span class="line">        self.func(<span class="number">0</span>,target,[],candidates,len_nums)</span><br><span class="line">        <span class="keyword">return</span> self.X</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self,index,target,x,nums,len_nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">            self.X.append(x[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len_nums):</span><br><span class="line">            <span class="comment"># 去重,如【1，1，7】---&gt;【1，7】</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target - nums[i]&gt;=<span class="number">0</span>:</span><br><span class="line">                self.func(i+<span class="number">1</span>,target-nums[i],x+[nums[i]],nums,len_nums)</span><br></pre></td></tr></table></figure>
<h4 id="41-缺失的第一个正数（B-）"><a href="#41-缺失的第一个正数（B-）" class="headerlink" title="41. 缺失的第一个正数（B+）"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a>（B+）</h4><p>分析：</p>
<p>注意：你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的空间。</p>
<p>（1）首先把数组内，范围在 ( 0,  n ] 元素x，放到nums[x - 1]，类似桶排序中的找位置。<br>（2）放好之后，进行遍历，找第一个 i + 1 != nums[i]，返回 i + 1，就是结果，如果没有就返回 n + 1。</p>
<p>（3）所以，最小的正整数很重要，如果是第一个没出现的数，就不能这样做了。</p>
<p>桶排序~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt;= n <span class="keyword">and</span> nums[i] != i + <span class="number">1</span>:  <span class="comment"># nums[i] != i + 1 如果相等或者是本身就没必要替换了，避免死循环</span></span><br><span class="line">                <span class="keyword">if</span> nums[nums[i] - <span class="number">1</span>] == nums[i]:  <span class="comment"># 获取当前位置的数据，减去1是为了得到 在list要插入的位置</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i != nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>第二种。取巧，不过是不是不满足常数空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_,max_ = min(nums), max(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> min_ &gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, max_):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">return</span> max(<span class="number">1</span>,max_+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>第三种 ~~ 二。plus</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/27/leetcode-排序一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/leetcode-排序一/" itemprop="url">leetcode-排序一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T11:02:59+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/例行打卡/" itemprop="url" rel="index">
                    <span itemprop="name">例行打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>菜    <a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">1030. 距离顺序排列矩阵单元格</a>（C+）</li>
<li>中    <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a>（B+）<a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a>（C+）<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>（C）</li>
<li>危    <a href="https://leetcode-cn.com/problems/random-pick-with-blacklist/" target="_blank" rel="noopener">710. 黑名单中的随机数</a>（A-）</li>
</ul>
<p>总结：今天的效率还可以。不过，又出现钻牛角尖的情况。简单的问题卡了好久。好在最后迎刃而解。有时候需要暂时搁置，效率优先。</p>
<hr>
<h4 id="1030-距离顺序排列矩阵单元格（C-）"><a href="#1030-距离顺序排列矩阵单元格（C-）" class="headerlink" title="1030. 距离顺序排列矩阵单元格（C+）"></a><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">1030. 距离顺序排列矩阵单元格</a>（C+）</h4><p>分析：看了一下别人的思路，大致就是广度遍历，深度遍历。题意很好理解。就是构建矩阵，然后根据原点求距离排序。 矩阵用遍历，原点距离用abs（），排序用sorted。优答：使用了lambda感觉简明不少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allCellsDistOrder</span><span class="params">(self, R: int, C: int, r0: int, c0: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(p1,p2)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> int(abs(p1[<span class="number">0</span>]-p2[<span class="number">0</span>])+abs(p1[<span class="number">1</span>]-p2[<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        dic = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(R):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">                dic.append([distance([i,j],[r0,c0]),[i,j]])</span><br><span class="line">        dic = sorted(dic,key=(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dic)):</span><br><span class="line">            dic[i] = dic[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dic</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><ul>
<li><p>sorted用法。与sort区别，不影响结构。</p>
<p>sorted返回一个有序的副本，并且类型总是列表。</p>
<p>sort对原列表进行排序，无返回值。</p>
</li>
<li><p>sort/sorted方法还有两个可选参数：key和reverse</p>
<ul>
<li>key在使用时必须提供一个排序过程总调用的函数：</li>
<li>reverse实现降序排序，需要提供一个布尔值：True为倒序排列，False为正序排列</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = [&#123;<span class="string">'name'</span>:<span class="string">'abc'</span>,<span class="string">'age'</span>:<span class="number">20</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'def'</span>,<span class="string">'age'</span>:<span class="number">30</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'ghi'</span>,<span class="string">'age'</span>:<span class="number">25</span>&#125;]     <span class="comment">#列表中的元素为字典 </span></span><br><span class="line">    &gt;&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(s)</span>:</span> </span><br><span class="line">           <span class="keyword">return</span> s[<span class="string">'age'</span>] </span><br><span class="line">    &gt;&gt;&gt; ff = sorted(f,key = age)      <span class="comment">#自定义函数按列表f中字典的age从小到大排序  </span></span><br><span class="line">     </span><br><span class="line">    [&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'name'</span>: <span class="string">'abc'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'name'</span>: <span class="string">'ghi'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'name'</span>: <span class="string">'def'</span>&#125;] </span><br><span class="line">     </span><br><span class="line">    &gt;&gt;&gt; f2 = sorted(f,key = <span class="keyword">lambda</span> x:x[<span class="string">'age'</span>])    <span class="comment">#如果觉得上面定义一个函数代码不美观，可以用lambda的形式来定义函数,效果同上</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="148-排序链表（B-）"><a href="#148-排序链表（B-）" class="headerlink" title="148. 排序链表（B+）"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a>（B+）</h4><p>分析：应该算是很经典的题了吧。一开始想的很简单。后来发现不对，没那么容易。简单的讲就是归并的思想。先把所有链表都分开，然后排序，再拼接。排序时使用了快慢针。快针分链表时计数，慢针来记录中间指针位置。然后从首中开始向后比较。 </p>
<p>递归归并问题卡了我1个多小时。就是想不通，为什么分开之后排序了。终于灵光一现。先分化到底端。然后排序，然后往回找。想通之后，发现就是最基础的归并。</p>
<p>1342》13，42》1，3    2，4》13， 24》1234</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        主要是使用归并的思路 先分再合</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.minute(head)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minute</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        这个方法主要是实现分的操作</span></span><br><span class="line"><span class="string">        分的过程用快慢指针实现</span></span><br><span class="line"><span class="string">        :param head:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        quick, slow, temp = head, head, head</span><br><span class="line">        <span class="keyword">while</span> quick <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> quick.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            quick = quick.next.next</span><br><span class="line">        temp.next = <span class="literal">None</span>  <span class="comment"># 这一步就是将整个链表从中间分开 失去这一步 后面将无限循环</span></span><br><span class="line"></span><br><span class="line">        i = self.minute(head)</span><br><span class="line">        j = self.minute(slow)</span><br><span class="line">        <span class="keyword">return</span> self.Combined(i, j)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Combined</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        这个方法主要实现合的操作</span></span><br><span class="line"><span class="string">        合的过程就是从i 和 j开始比较 就是从开头和中间开始比较 将两个相比小的排在head后</span></span><br><span class="line"><span class="string">        最后返回head即可</span></span><br><span class="line"><span class="string">        :param i:ListNode</span></span><br><span class="line"><span class="string">        :param j:ListNode</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        TempNode = ListNode(<span class="number">0</span>)</span><br><span class="line">        temp = TempNode</span><br><span class="line">        <span class="keyword">while</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> i.val &lt;= j.val:</span><br><span class="line">                temp.next = i</span><br><span class="line">                i = i.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.next = j</span><br><span class="line">                j = j.next</span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp.next = i</span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp.next = j</span><br><span class="line">        <span class="keyword">return</span> TempNode.next</span><br></pre></td></tr></table></figure>
<h4 id="324-摆动排序-II（C-）"><a href="#324-摆动排序-II（C-）" class="headerlink" title="324. 摆动排序 II（C+）"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a>（C+）</h4><p>分析：题意简单，但是思考出最优解还是需要细心和耐心的。参考答案，很棒~直接贴出来。</p>
<blockquote>
<p>来自StefanPochmann</p>
<p>先对数组排序，分为大数部分和小数部分，再穿插排序。 注意顺序，例如[1，2，4，4，4，6]这个数组，通过降序穿插得到[4,6,2,4,1,4]。 如果顺序排列，则会得到[1,4,2,4,4,6]不满足要求。 这里是因为我们想尽量将小数部分的最大数放在边上，这样只用靠近一个大数部分的最大数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleSort</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        half = len(nums[::<span class="number">2</span>])</span><br><span class="line">        nums[::<span class="number">2</span>], nums[<span class="number">1</span>::<span class="number">2</span>] = nums[:half][::<span class="number">-1</span>],nums[half:][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="75-颜色分类（C）"><a href="#75-颜色分类（C）" class="headerlink" title="75. 颜色分类（C）"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>（C）</h4><p>分析：题意，0，1，2排序。不可以使用sort。</p>
<p>要求：一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</p>
<p>思考仅使用常数空间的一趟扫描算法！</p>
<blockquote>
<p>0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = n - <span class="number">1</span>            <span class="comment">#取末尾位置,计数往前添加.</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                nums.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                nums.insert(j,<span class="number">2</span>)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="710-黑名单中的随机数（A-）"><a href="#710-黑名单中的随机数（A-）" class="headerlink" title="710. 黑名单中的随机数（A-）"></a><a href="https://leetcode-cn.com/problems/random-pick-with-blacklist/" target="_blank" rel="noopener">710. 黑名单中的随机数</a>（A-）</h4><p>分析：感觉无从下手~直接借鉴思路。关键点在于黑名单的映射分类.</p>
<blockquote>
<p>思路：</p>
<ul>
<li>黑名单长度为<code>s</code>，我们从<code>[0, N-s)</code>中取随机值，这个随机值有可能在黑名单中，怎么办？</li>
<li><code>[0, N-s)</code>内的元素，如果有<code>i</code>个在黑名单中，那么在<code>[N-s, N)</code>中，必定有<code>i</code>个元素不在黑名单中</li>
<li>对<code>[0, N-s)</code>中的黑名单元素和<code>[N-s, N)</code>中不在黑名单中的元素做映射<code>m</code>，必定可以一一对应，怎么对应倒是无所谓</li>
<li>从<code>[0, N-s)</code>中取随机值<code>r</code>，如果<code>r</code>不在黑名单中，直接返回；如果<code>r</code>在黑名单中，则<code>m[r]</code>一定不在黑名单，返回<code>m[r]</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint       <span class="comment">#生成随机整数.有界限.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, N, blacklist)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.s = N - len(blacklist)</span><br><span class="line">      </span><br><span class="line">        b_lt_s = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> blacklist <span class="keyword">if</span> i &lt; self.s&#125;   <span class="comment"># 小于s的黑名单元素集合</span></span><br><span class="line"> </span><br><span class="line">        w_gt_s = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.s, N)&#125; - set(blacklist) <span class="comment"># 大于s的非黑名单元素集合</span></span><br><span class="line">       </span><br><span class="line">        self.m = &#123;k: v <span class="keyword">for</span> k,v <span class="keyword">in</span> zip(b_lt_s, w_gt_s)&#125;    <span class="comment"># 做映射，使用zip方便一点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r = randint(<span class="number">0</span>, self.s<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> self.m <span class="keyword">else</span> self.m[r]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/22/leetcodede-队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/leetcodede-队列/" itemprop="url">leetcodede_队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-22T16:25:35+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/每日打卡/" itemprop="url" rel="index">
                    <span itemprop="name">每日打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>菜    933（B+）</li>
<li>中    <strong>621（A-）</strong> 、622（C+） 、641（C+）</li>
<li>危    <strong>862（A+）</strong></li>
</ul>
<p>个人总结：队列的题普遍综合性，理解题意就需要花费一定时间。队列是先进先出。有几道都是自定义构造类，实现功能。还是比较锻炼代码基础的。逻辑性还是不好，代码构建时有一些心浮气躁。需要沉下心，慢慢努力。</p>
<p>额外扩展：collections模块的Counter类</p>
<hr>
<h4 id="933-最近的请求次数（B）"><a href="#933-最近的请求次数（B）" class="headerlink" title="933. 最近的请求次数（B）"></a><a href="https://leetcode-cn.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">933. 最近的请求次数</a>（B）</h4><p>分析：蛤？看题看了三遍，也没读懂要求到底是什么。不是出题人表达能力欠佳，要不就是我理解欠佳。暂且归于后者吧。看了评论知道了题意。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*法1：其实这题很简单的，用队列的enqueue和dequeue做很简洁（队列用C语言做要啰嗦点）*/</span><br><span class="line">/*比如输入是[&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;]</span><br><span class="line">           [[],[1],[100],[3001],[3002]]</span><br><span class="line">第一组是(RecentCounter, [])这个意思我觉得是创立一个RecentCounter型的指针并返回，就如这个函数RecentCounter* recentCounterCreate() </span><br><span class="line">第二组是(ping, [1])调用了ping函数，就是这个int recentCounterPing(RecentCounter* obj, int t) ，1时刻和它之前的1-3000时刻之内都应记录好，其实应该是从0开始递增下去的吧，1-3000到1内的负数不用考虑，所以返回值是1；</span><br><span class="line">第三组是(ping, [100])，(100 - 3000, 100)这个范围之内的值都应记录起来，就是要包括第二组的</span><br><span class="line">(ping, [1])，所以返回值是2；</span><br><span class="line">第四组是(ping, [3001])，(3001 - 3000, 3001)这个范围之内，也就是包括了第二组的(ping, [1])和第三组的(ping, [100])，返回值是3；</span><br><span class="line">第五组是(ping, [3002])，(3002 - 3000, 3002)这个范围之内，也就是包括了第三组的(ping, [100])和第四组的(ping, [3001])，第二组的(ping, [1])不在范围内，舍掉，此时返回值是3；</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pinglist=[]</span><br><span class="line">        self.minindex=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, t: int)</span> -&gt; int:</span></span><br><span class="line">        self.pinglist.append(t)</span><br><span class="line">        <span class="keyword">while</span> t &gt; self.pinglist[self.minindex] + <span class="number">3000</span>:</span><br><span class="line">            self.minindex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(self.pinglist) - self.minindex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RecentCounter()</span></span><br><span class="line"><span class="comment"># param_1 = obj.ping(t)</span></span><br></pre></td></tr></table></figure>
<h4 id="621-任务调度器（A-）"><a href="#621-任务调度器（A-）" class="headerlink" title="621. 任务调度器（A-）"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a>（A-）</h4><p>分析：CPU调度，一开始就被这标题吓唬住了。了解题意后，也没有什么好的想法。看答案，基本都是一个路子。找到一个计算公式。 (count[25] - 1) * (n + 1) + maxCount</p>
<p>公式详解：</p>
<ul>
<li>假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1</li>
<li>要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount</li>
<li>公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">        count = collections.Counter(tasks)</span><br><span class="line">        most = count.most_common()[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#most_common()返回一个TopN列表。如果n没有被指定，则返回所有元素。当多个元素计数值相同时，排列是无确定顺序的。</span></span><br><span class="line">        num_most = len([i <span class="keyword">for</span> i, v <span class="keyword">in</span> count.items() <span class="keyword">if</span> v == most])</span><br><span class="line">        time = (most - <span class="number">1</span>) * (n + <span class="number">1</span>) + num_most</span><br><span class="line">        <span class="keyword">return</span> max(time, len(tasks))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="扩展：collections模块的Counter类"><a href="#扩展：collections模块的Counter类" class="headerlink" title="扩展：collections模块的Counter类"></a>扩展：collections模块的Counter类</h3><p>Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。</p>
<p>参考：<a href="http://www.pythoner.com/205.html" target="_blank" rel="noopener">http://www.pythoner.com/205.html</a></p>
<p>第二种方法，基本上区别不大。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">        output = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">            output[ord(i)-ord(<span class="string">'A'</span>)] = output[ord(i)-ord(<span class="string">'A'</span>)]+<span class="number">1</span>   <span class="comment">#返回ASCII值</span></span><br><span class="line"> </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        len_o = <span class="number">0</span></span><br><span class="line">        max_o = max(output)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> output:</span><br><span class="line">            <span class="keyword">if</span> i==max_o:</span><br><span class="line">                count = count+<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> max(len(tasks),(max_o<span class="number">-1</span>)*(n+<span class="number">1</span>)+count)</span><br></pre></td></tr></table></figure>
<p>ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。</p>
<h4 id="622-设计循环队列（C）"><a href="#622-设计循环队列（C）" class="headerlink" title="622. 设计循环队列（C）"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a>（C）</h4><p>分析：构建类，设计循环队列。很好理解，也算是第一次见这种题型。构建循环队列可以使用数组或者是链表。</p>
<blockquote>
<ul>
<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>
<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>
<li><code>isFull()</code>: 检查循环队列是否已满。</li>
</ul>
</blockquote>
<p>循环队列关键点在于<code>avail = (self._front + self._size ) % len(self._data)</code>第一个数位置变动，如果大于循环数组长度，就可以在队列前面添加元素。其他“%”皆是如此。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span>      </span><br><span class="line">        self._data = [<span class="literal">None</span>] * k   <span class="comment"># 数据</span></span><br><span class="line">        self._size = <span class="number">0</span>            <span class="comment"># 目前储存的个数</span></span><br><span class="line">        self._front = <span class="number">0</span>           <span class="comment"># 第一个数的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        avail = (self._front + self._size ) % len(self._data)  <span class="comment"># （第一个数的位置 + 目前储存的个数） % 循环数组长度</span></span><br><span class="line">        self._data[avail] = value</span><br><span class="line">        self._size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span><span class="params">(self)</span>:</span>       </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty()：</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        answer = self._data[self._front]</span><br><span class="line">        self._data[self._front] = <span class="literal">None</span></span><br><span class="line">        self._front = (self._front + <span class="number">1</span>) % len(self._data) <span class="comment"># （第一个数的位置 + 1） % 循环数组长度</span></span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span><span class="params">(self)</span>:</span>       </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self._data[self._front]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self._data[(self._front + self._size - <span class="number">1</span>) % len(self._data)]  <span class="comment"># （第一个数的位置 + 目前储存的个数 - 1 ） % 循环数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span>       </span><br><span class="line">        <span class="keyword">return</span> self._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self._size == len(self._data)</span><br></pre></td></tr></table></figure>
<h4 id="641-设计循环双端队列（C）"><a href="#641-设计循环双端队列（C）" class="headerlink" title="641. 设计循环双端队列（C）"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a>（C）</h4><p>分析：跟前一题基本类似。加了一个双端要求。题中要求不可以使用内置的双端队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the deque to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.size = k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds an item at the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isFull():</span><br><span class="line">            self.queue.insert(<span class="number">0</span>,value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds an item at the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isFull():</span><br><span class="line">            self.queue.append(value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Deletes an item from the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            self.queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            self.queue.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the last item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == self.size</span><br></pre></td></tr></table></figure>
<p>第二种。是同622一样的做法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: <span class="string">'int'</span>)</span>:</span></span><br><span class="line">        self.a = [<span class="literal">None</span>] * k <span class="comment"># internal buffer</span></span><br><span class="line">        self.k = k <span class="comment"># capacity - max number of elements that deque can hold</span></span><br><span class="line">        self.sz = <span class="number">0</span> <span class="comment"># current size</span></span><br><span class="line">        self.b = k - <span class="number">1</span> <span class="comment"># points to current 'back' element</span></span><br><span class="line">        self.f = <span class="number">0</span> <span class="comment"># points to current 'front' element        </span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_idx</span><span class="params">(self, i)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>: <span class="keyword">return</span> self.k - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_idx</span><span class="params">(self, i)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) % self.k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span><span class="params">(self, v: <span class="string">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == self.k: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.f = self.prev_idx(self.f)</span><br><span class="line">        self.a[self.f] = v</span><br><span class="line">        self.sz += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span><span class="params">(self, v: <span class="string">'int'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == self.k: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.b = self.next_idx(self.b)</span><br><span class="line">        self.a[self.b] = v</span><br><span class="line">        self.sz += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span><span class="params">(self)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.f = self.next_idx(self.f)</span><br><span class="line">        self.sz -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span><span class="params">(self)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.b = self.prev_idx(self.b)</span><br><span class="line">        self.sz -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span><span class="params">(self)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.a[self.f]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span><span class="params">(self)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">if</span> self.sz == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.a[self.b]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span> -&gt; 'bol':</span> </span><br><span class="line">        <span class="keyword">return</span> self.sz == <span class="number">0</span>        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span> -&gt; 'bool':</span></span><br><span class="line">        <span class="keyword">return</span> self.sz == self.k</span><br></pre></td></tr></table></figure>
<h4 id="862-和至少为-K-的最短子数组（A-）"><a href="#862-和至少为-K-的最短子数组（A-）" class="headerlink" title="862. 和至少为 K 的最短子数组（A+）"></a><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="noopener">862. 和至少为 K 的最短子数组</a>（A+）</h4><p>分析：结合了队列和动态规划。由于题中给了 （1 &lt;= K）所以，必须要保证，dp 后一个值减去前一个值，而且是必须大于0才是有效的。从双端队列左侧出队，来寻求最短的字数组是精华所在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSubarray</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span>        </span><br><span class="line"> </span><br><span class="line">        n, dp = len(A), [<span class="number">0</span>]  <span class="comment"># 初始化dp[i] = A[0]+A[1]+...+A[i-1]</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> A: </span><br><span class="line">            dp.append(dp[<span class="number">-1</span>] + v)</span><br><span class="line"> </span><br><span class="line">        queue, res = collections.deque(), n + <span class="number">1</span>  <span class="comment"># 初始化双端队列、结果变量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> dp[i] &lt;= dp[queue[<span class="number">-1</span>]]: <span class="comment">#因为K &gt;= 1</span></span><br><span class="line">                queue.pop()  <span class="comment"># 出队, 删除不符合的</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> dp[i] - dp[queue[<span class="number">0</span>]] &gt;= K:  <span class="comment">#满足题意。</span></span><br><span class="line">                res = min(res, i - queue.popleft())  <span class="comment"># 从双端队列左边出队，并更新最短距离。</span></span><br><span class="line"> </span><br><span class="line">            queue.append(i)  <span class="comment"># 入队</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt; n + <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span>  <span class="comment">#返回最优解，限制不可能超过列表元素。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solu = Solution()</span><br><span class="line">    A, K = [<span class="number">2</span>, <span class="number">-1</span>, <span class="number">2</span>], <span class="number">3</span></span><br><span class="line">    print(solu.shortestSubarray(A, K))</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/20/leetcode 栈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/leetcode 栈/" itemprop="url">leetcode（栈）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T09:37:57+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常打卡/" itemprop="url" rel="index">
                    <span itemprop="name">日常打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  979 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>菜    682(E)</p>
<p>中    71(C-)    、394(C+)</p>
<p>危    42(B+)    、84(A)</p>
</blockquote>
<blockquote>
<p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
</blockquote>
<p>小练总结：栈的题相对来说比较简单，需要注意的问题就是模型转化跟栈结合时需要细心一些。实际问题转化为算法时，逻辑上的判断至关重要。</p>
<hr>
<h4 id="682-棒球比赛（E）"><a href="#682-棒球比赛（E）" class="headerlink" title="682. 棒球比赛（E）"></a><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">682. 棒球比赛</a>（E）</h4><p>分析：栈初试身手。选了一道简单难度的题。嗯，果然很简单。读清题意，解答很容易的。栈最后位，表示就是用队列的[-1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calPoints</span><span class="params">(self, ops: List[str])</span> -&gt; int:</span></span><br><span class="line">        points = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(ops):</span><br><span class="line">            <span class="keyword">if</span> ops[i] == <span class="string">'C'</span>:</span><br><span class="line">                points.pop()</span><br><span class="line">            <span class="keyword">elif</span> ops[i] == <span class="string">'+'</span>:</span><br><span class="line">                points.append(points[<span class="number">-1</span>] + points[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">elif</span> ops[i] == <span class="string">'D'</span>:</span><br><span class="line">                points.append(points[<span class="number">-1</span>] * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points.append(int(ops[i]))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum(points)</span><br></pre></td></tr></table></figure>
<h4 id="71-简化路径（C-）"><a href="#71-简化路径（C-）" class="headerlink" title="71. 简化路径（C-）"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a>（C-）</h4><p>分析：本质上还是一道简单的栈表示。题意理解上稍微复杂一点。如果不熟悉Linux路径表示，需要细心看一下。..删除的是前面出现的路径。整体思路就是分段，去空，判断，构建栈。最后别忘了拼接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        l = path.split(<span class="string">'/'</span>)</span><br><span class="line">        l = [i <span class="keyword">for</span> i <span class="keyword">in</span> l <span class="keyword">if</span> i]</span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            c = l.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span>+<span class="string">'/'</span>.join(stack)</span><br></pre></td></tr></table></figure>
<h4 id="394-字符串解码（C-）"><a href="#394-字符串解码（C-）" class="headerlink" title="394. 字符串解码（C+）"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a>（C+）</h4><p>分析：题意容易理解。关键点在于，数字和字母构建双重栈。如果没有数字添加默认1，最后依次匹配相乘。关键点在于，字符拼接时注意翻转。因为栈后进先出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        stack = []<span class="comment">#模拟栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">']'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp1 = []<span class="comment">#存字母</span></span><br><span class="line">                <span class="keyword">while</span> stack[<span class="number">-1</span>] != <span class="string">"["</span>:</span><br><span class="line">                    temp1.append(stack.pop())</span><br><span class="line">                temp1_list = list(temp1)</span><br><span class="line">                stack.pop()<span class="comment">#去除[</span></span><br><span class="line">                    </span><br><span class="line">                temp2 = []<span class="comment">#存数字</span></span><br><span class="line">                <span class="keyword">if</span> len(stack)!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack[<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">"0123456789"</span>:  <span class="comment">#做循环是为了防止高位数出现</span></span><br><span class="line">                        temp2.append(stack.pop())</span><br><span class="line">                        <span class="keyword">if</span> len(stack)==<span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> temp2 == []:</span><br><span class="line">                    temp2= [<span class="string">'1'</span>]</span><br><span class="line">                stack.append(eval(<span class="string">""</span>.join(temp2[::<span class="number">-1</span>]))*<span class="string">""</span>.join(temp1[::<span class="number">-1</span>]))<span class="comment">#先反转列表形成字符串，然后相乘，添加到stack</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> stack:</span><br><span class="line">            result += i</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>遇事不决用正则。正则用好了，超级容易实现，然鹅！这道题考察栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'['</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = re.sub(<span class="string">r"(\d+)\[(\w+)\]"</span>,<span class="keyword">lambda</span> m:int(m.group(<span class="number">1</span>))*m.group(<span class="number">2</span>),s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h4 id="42-接雨水（B-）"><a href="#42-接雨水（B-）" class="headerlink" title="42. 接雨水（B+）"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a>（B+）</h4><p>分析：hard难度，就有点意思了。感觉更多的是，找到规律。两边分别遍历一下，墙和水被加了两次，再减去墙。最后减去整体面积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        h1 = <span class="number">0</span></span><br><span class="line">        h2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            h1 = max(h1,height[i])</span><br><span class="line">            h2 = max(h2,height[-i<span class="number">-1</span>])</span><br><span class="line">            ans = ans + h1 + h2 -height[i]</span><br><span class="line">        <span class="keyword">return</span>  ans - len(height)*h1</span><br></pre></td></tr></table></figure>
<h4 id="84-柱状图中最大的矩形（A）"><a href="#84-柱状图中最大的矩形（A）" class="headerlink" title="84. 柱状图中最大的矩形（A）"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a>（A）</h4><p>分析：感觉许久未逢的几何生疏感，想了一阵才缕清算法思路，虽然对步骤还有点违和感。</p>
<p>算法书写不难，不过这个思路的构建还是需要学习一下的。关键点在于，右侧高于左侧，放入栈中。低于左侧，就开始计算面积。判断，左右边界，求面积。是i中的高，还是栈中的高，直接影响面积。最后加个0是收尾计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        heights.append(<span class="number">0</span>)   <span class="comment">#控制边界做最后收尾验算</span></span><br><span class="line">        stack = [<span class="number">-1</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:  <span class="comment">#如果栈中圆柱高于新圆柱</span></span><br><span class="line">                s = stack.pop()  <span class="comment">#i&lt;i-1.右边界为i-1出栈。</span></span><br><span class="line">                res = max(res,(i-stack[<span class="number">-1</span>]<span class="number">-1</span>)*heights[s])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/19/leetcode 脑筋急转弯/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/leetcode 脑筋急转弯/" itemprop="url">leetcode（脑筋急转弯）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T09:48:15+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/每日打卡/" itemprop="url" rel="index">
                    <span itemprop="name">每日打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  637 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>菜  292(E)</p>
<p>中  319(D)  777(B+)</p>
<p>危</p>
<p>今天就算是娱乐专场了。三道脑筋急转弯。</p>
<p>加餐：zip函数（）</p>
<hr>
<h4 id="292-Nim游戏（E）"><a href="#292-Nim游戏（E）" class="headerlink" title="292. Nim游戏（E）"></a><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim游戏</a>（E）</h4><p>分析：额。一开始有点懵，这道题要考什么啊。转弯转在哪里啊。想到了4这个数，加个判断就完成了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="319-灯泡开关（D）"><a href="#319-灯泡开关（D）" class="headerlink" title="319. 灯泡开关（D）"></a><a href="https://leetcode-cn.com/problems/bulb-switcher/" target="_blank" rel="noopener">319. 灯泡开关</a>（D）</h4><p>分析：这道题，有点意思。需要考虑到开关状态跟因子数相关。</p>
<p>（1）第i轮时，被切换的灯泡位置是i的倍数。<br>（2）由（1）得出，对于第p个灯泡来说，只有其第“因子”轮才会切换，若其有q个因子，则最终被切换q次。因为初始状态是关闭状态，那么因子数是奇数的灯泡最终是亮着的。<br>（3）只有平方数的因子个数不是成对出现，举例：4=1*4,2*2，其因子是1,2,4。<br>（4）那么题目最终转化为1~n里平方数的个数，进而转化为对n开平方根，向下取整即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulbSwitch</span><span class="params">(self, n: int)</span> -&gt; int:</span>       </span><br><span class="line">        <span class="keyword">return</span> math.floor(n ** <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="777-在LR字符串中交换相邻字符（B-）"><a href="#777-在LR字符串中交换相邻字符（B-）" class="headerlink" title="777. 在LR字符串中交换相邻字符（B+）"></a><a href="https://leetcode-cn.com/problems/swap-adjacent-in-lr-string/" target="_blank" rel="noopener">777. 在LR字符串中交换相邻字符</a>（B+）</h4><p>L只能跨越X左移，R只能跨越X又移，LR相互之间不可以移动</p>
<p>用两个计数单位分别记录，LX和XR   XL和RX。一个正一个负，来比较抵消。</p>
<p>需要注意的是，使用到了zip()函数，扩展在下面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start: str, end: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment">#    left move l right move r</span></span><br><span class="line">        end_has_l = <span class="number">0</span></span><br><span class="line">        start_has_r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> zip(start, end):           <span class="comment">#zip打包成元组（取最短的）</span></span><br><span class="line">            <span class="keyword">if</span> s == e:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> end_has_l <span class="keyword">and</span> s == <span class="string">"L"</span> <span class="keyword">and</span> e == <span class="string">"X"</span>:</span><br><span class="line">                <span class="comment"># start can move this l to left</span></span><br><span class="line">                end_has_l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> start_has_r <span class="keyword">and</span> s == <span class="string">"X"</span> <span class="keyword">and</span> e == <span class="string">"R"</span>:</span><br><span class="line">                <span class="comment"># start has r to move right</span></span><br><span class="line">                start_has_r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> e == <span class="string">"L"</span>:</span><br><span class="line">                end_has_l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s == <span class="string">"R"</span>:</span><br><span class="line">                start_has_r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> start_has_r == end_has_l == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="zip-函数的使用"><a href="#zip-函数的使用" class="headerlink" title="zip()函数的使用"></a>zip()函数的使用</h3><p> a = [1,2,3]</p>
<p> b = [4,5,6]<br> c = [4,5,6,7,8]<br> zipped = zip(a,b)     # 打包为元组的列表<br>[(1, 4), (2, 5), (3, 6)]<br> zip(a,c)              # 元素个数与最短的列表一致<br>[(1, 4), (2, 5), (3, 6)]<br> zip(<em>zipped)          # 与 zip 相反，</em>zipped 可理解为解压，返回二维矩阵式<br>[(1, 2, 3), (4, 5, 6)]</p>
<blockquote>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nums = [&apos;flower&apos;,&apos;flow&apos;,&apos;flight&apos;]</span><br><span class="line">&gt;&gt;&gt;for i in zip(*nums):</span><br><span class="line">&gt;&gt;&gt;    print(i)</span><br><span class="line">&gt;&gt;&gt;    </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;    </span><br><span class="line">&gt;&gt;&gt;(&apos;f&apos;, &apos;f&apos;, &apos;f&apos;)</span><br><span class="line">&gt;&gt;&gt;(&apos;l&apos;, &apos;l&apos;, &apos;l&apos;)</span><br><span class="line">&gt;&gt;&gt;(&apos;o&apos;, &apos;o&apos;, &apos;i&apos;)</span><br><span class="line">&gt;&gt;&gt;(&apos;w&apos;, &apos;w&apos;, &apos;g&apos;) </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/18/KMP算法梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/KMP算法梳理/" itemprop="url">KMP算法梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T21:33:51+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  342 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刷LeetCode算法题的时候，碰到了这个KMP。觉得还有点意思。相对来说还是有点难度，就做个笔记梳理一下。</p>
<hr>
<p>KMP算法则可以将时间复杂度下降到O(m+n),和O(m*n)相比明显下降。</p>
<p>A，B 》 j，i  不等 为0     A，C  》 j，i  不等为0     一直到  A，A 》 j，i  相等记作1.然后同时进一位。B，B 》</p>
<p>j，i  相等 前位置加1 。C ， D不等，往前推。。A，D也不等，记作0</p>
<p><img src="https://i.loli.net/2019/04/18/5cb89afbdef0d.png" alt="Snipaste_2019-04-18_23-32-20"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMP_algorithm</span><span class="params">(string, substring)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    KMP字符串匹配的主函数</span></span><br><span class="line"><span class="string">    若存在字串返回字串在字符串中开始的位置下标，或者返回-1</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    pnext = gen_pnext(substring)</span><br><span class="line">    n = len(string)</span><br><span class="line">    m = len(substring)</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;n) <span class="keyword">and</span> (j&lt;m):</span><br><span class="line">        <span class="keyword">if</span> (string[i]==substring[j]):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (j!=<span class="number">0</span>):</span><br><span class="line">            j = pnext[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (j == m):</span><br><span class="line">        <span class="keyword">return</span> i-j</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pnext</span><span class="params">(substring)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    构造临时数组pnext</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    index, m = <span class="number">0</span>, len(substring)</span><br><span class="line">    pnext = [<span class="number">0</span>]*m</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m:</span><br><span class="line">        <span class="keyword">if</span> (substring[i] == substring[index]):</span><br><span class="line">            pnext[i] = index + <span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (index!=<span class="number">0</span>):</span><br><span class="line">            index = pnext[index<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pnext[i] = <span class="number">0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pnext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    string = <span class="string">'abcxabcdabcdabcy'</span></span><br><span class="line">    substring = <span class="string">'abcdabcy'</span></span><br><span class="line">    out = KMP_algorithm(string, substring)</span><br><span class="line">    print(out)</span><br></pre></td></tr></table></figure>
<p>和主字符串对比时，如果不同，看前一位pnext值对应的字母作为分隔线。为零，就是将整个字符串都后移。</p>
<p><img src="https://i.loli.net/2019/04/18/5cb89b971384d.png" alt="BBBBB"></p>
<h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><p><a href="https://www.bilibili.com/video/av3246487" target="_blank" rel="noopener">b站视频很不错</a></p>
<p><a href="https://blog.csdn.net/weixin_39561100/article/details/80822208" target="_blank" rel="noopener">python代码实现</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰KMP</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/18/leetcode（25-29）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/leetcode（25-29）/" itemprop="url">leetcode（25~29）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T09:36:18+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常打卡/" itemprop="url" rel="index">
                    <span itemprop="name">日常打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  885 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>菜：26（D），27（D=），<strong>28</strong>（<strong>A+</strong>/E）</p>
<p>中：<strong>29（B+）</strong></p>
<p>死：25（B）</p>
<p>今日总结：</p>
<hr>
<h4 id="25-k个一组翻转链表（B）"><a href="#25-k个一组翻转链表（B）" class="headerlink" title="25. k个一组翻转链表（B）"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. k个一组翻转链表</a>（B）</h4><p>分析：久违的链表题，虽然是hard难度，但是并没有需要特别在意的地方。对给定的值进行分情况讨论，翻转链表的方式也是经常使用的。链表整合时的方法还是要多熟悉一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = jump = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = r = l = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> r <span class="keyword">and</span> count &lt; k:      <span class="comment">#用r来定位翻转范围</span></span><br><span class="line">                r = r.next</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                pre, cur = r, l</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                    cur.next, cur, pre = pre, cur.next, cur</span><br><span class="line">                jump.next, jump, l = pre, l, r   <span class="comment">#初始l的位置，然后将翻转后的链表转出。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h4 id="26-删除排序数组中的重复项（D）"><a href="#26-删除排序数组中的重复项（D）" class="headerlink" title="26. 删除排序数组中的重复项（D）"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a>（D）</h4><p>分析：双指针的用法如果是第一次接触。还是觉得蛮有趣的。很好理解，慢指针记录当前不同元素个数，快指针对比寻找非重复元素（此题就是比较相邻即可），当找到非重复的赋值给慢指针对应位置即可。</p>
<p>这个题的引用法，还是挺有趣的。返回int。输出list。需要更改nums</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">1</span>        <span class="comment">#length默认nums[0]不需要变化。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]:</span><br><span class="line">                nums[length] = nums[i+<span class="number">1</span>]</span><br><span class="line">                length = length + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
<h4 id="27-移除元素（D-）"><a href="#27-移除元素（D-）" class="headerlink" title="27. 移除元素（D-）"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a>（D-）</h4><p>分析：上同，没什么变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
<h4 id="28-实现strStr-（A-E）"><a href="#28-实现strStr-（A-E）" class="headerlink" title="28. 实现strStr()（A+/E）"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现strStr()</a>（A+/E）</h4><p>分析：还是比较有争议的一道题，涉及是否使用内置函数。如果，单纯算法角度。应该使用KMP算法。难度升高到hard。不管怎样学习一下，KMP算法。内置函数方法直接用find。太简单就省略了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(haystack) - len(needle) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>KMP版本<strong>（A+）</strong>该算法，会单独整理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> haystack == <span class="literal">None</span> <span class="keyword">or</span> needle == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#generate next array, need O(n) time</span></span><br><span class="line">        i, j, m, n = <span class="number">-1</span>, <span class="number">0</span>, len(haystack), len(needle)</span><br><span class="line">        next = [<span class="number">-1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> j &lt; n - <span class="number">1</span>:  </span><br><span class="line">            <span class="comment">#needle[k] stands for prefix, neelde[j] stands for postfix</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span> <span class="keyword">or</span> needle[i] == needle[j]:   </span><br><span class="line">                i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">                next[j] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = next[i]</span><br><span class="line">        <span class="comment">#check through the haystack using next, need O(m) time</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> haystack[i] == needle[j]:</span><br><span class="line">                i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = next[j]</span><br><span class="line">        <span class="keyword">if</span> j == n:</span><br><span class="line">            <span class="keyword">return</span> i - j</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="29-两数相除（B-）"><a href="#29-两数相除（B-）" class="headerlink" title="29. 两数相除（B+）"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a>（B+）</h4><p>分析：注意这道题的要求。不可以使用乘，除，mod运算符。想了一下，大概使用数位运算吧。代码还是不太会实现。借鉴一下。<strong>初次使用这种方式，还是给与重视一下。</strong></p>
<p>&lt;&lt; 移位运算符。移位是指二进制。左移一，相当于变大一倍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)   <span class="comment">#判断符号是否相等。在结果处添加符号。</span></span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:   <span class="comment">#限定继续迭代分化问题</span></span><br><span class="line">            temp, i = divisor, <span class="number">1</span>          <span class="comment">#由1倍开始计算。</span></span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= temp:</span><br><span class="line">                dividend -= temp</span><br><span class="line">                res += i</span><br><span class="line">                i &lt;&lt;= <span class="number">1</span>        <span class="comment">#i和temp同时变大一倍。就相当于快速缩小范围。</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:   <span class="comment">#此处判断符号</span></span><br><span class="line">            res = -res</span><br><span class="line">        <span class="keyword">return</span> min(max(<span class="number">-2147483648</span>, res), <span class="number">2147483647</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qingxuanmingye.github.io/2019/04/17/leetcode（16，17，18，20，22）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crist">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CRIST兴趣使然">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/leetcode（16，17，18，20，22）/" itemprop="url">leetcode（16，17，18，20，22）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T09:33:52+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常打卡/" itemprop="url" rel="index">
                    <span itemprop="name">日常打卡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今日总结：做题效果不是很好，出现各种状况。感觉不是很难的题，就是陷入思维误区。还有两道题（18，22），暂且搁置。有点窝火，再努力吧。</p>
<hr>
<h4 id="16-最接近的三数之和（C）"><a href="#16-最接近的三数之和（C）" class="headerlink" title="16. 最接近的三数之和（C）"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a>（C）</h4><p>分析：跟之前的题很相识，一个求和，这个是求近似。直观想法还是老套路，排序，然后遍历，比较。</p>
<p>方法一：排序遍历比较，注意下，近似使用abs求绝对值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        gol_ans = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            k = len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j&lt;k:</span><br><span class="line">                cur_ans = nums[i]+nums[j]+nums[k]</span><br><span class="line">                <span class="keyword">if</span> cur_ans == target:</span><br><span class="line">                    <span class="keyword">return</span> cur_ans</span><br><span class="line">                <span class="keyword">if</span> abs(cur_ans-target) &lt; abs(gol_ans-target):</span><br><span class="line">                    gol_ans=cur_ans</span><br><span class="line">                <span class="keyword">if</span> cur_ans &gt; target:</span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> gol_ans</span><br></pre></td></tr></table></figure>
<p>方法二：优化运算时间，想法就是优先考虑两端情况，最大最小。然后其余情况正常，最后将结果。绝对值排序。选出最优。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        closest = []</span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums[<span class="number">0</span>:<span class="number">-2</span>]):</span><br><span class="line">            l,r = i+<span class="number">1</span>, length<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> num+nums[r]+nums[r<span class="number">-1</span>] &lt; target:</span><br><span class="line">                closest.append(num+nums[r]+nums[r<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">elif</span> num+nums[l]+nums[l+<span class="number">1</span>] &gt; target:</span><br><span class="line">                closest.append(num+nums[l]+nums[l+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                    closest.append(num+nums[r]+nums[l])</span><br><span class="line">                    <span class="keyword">if</span> num+nums[l]+nums[r] &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> num+nums[l]+nums[r] &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> target</span><br><span class="line">        closest.sort(key=<span class="keyword">lambda</span> x:abs(x-target))</span><br><span class="line">        <span class="keyword">return</span> closest[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="17-电话号码的字母组合（C）"><a href="#17-电话号码的字母组合（C）" class="headerlink" title="17. 电话号码的字母组合（C）"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a>（C）</h4><p>分析：每个数字列出对应字母，先读一个数字放入列表。再依次拼接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: </span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        table = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],            </span><br><span class="line">                 <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                 <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                 <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                 <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                 <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                 <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                 <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">        result = [<span class="string">''</span>]</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">            str_list = []</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> table[digit]:</span><br><span class="line">                str_list += [x + char <span class="keyword">for</span> x <span class="keyword">in</span> result]</span><br><span class="line">            result = str_list</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>优化后（A）</strong>。yield生成器返回结果。学习到了。还有函数构造这个也很巧妙。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        </span><br><span class="line">        dict = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],            </span><br><span class="line">                 <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                 <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                 <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                 <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                 <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                 <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                 <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(digits, comb = <span class="string">''</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(digits) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> dict[digits[<span class="number">0</span>]]:</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">from</span> helper(digits[<span class="number">1</span>:], comb + i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">yield</span> comb</span><br><span class="line">        <span class="keyword">return</span> list(helper(digits)) <span class="keyword">if</span> digits != <span class="string">''</span> <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<h4 id="18-四数之和（C）（暂）"><a href="#18-四数之和（C）（暂）" class="headerlink" title="18. 四数之和（C）（暂）"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a>（C）（暂）</h4><p>分析：emmm~四数之和来了，首先考虑顺着三数之和的思路，4个指针，固定两个数。两个数往中间逼近。考虑可能存在多种情况，需要加一条判断。双嵌套复杂度太高了，直接借鉴优化代码。</p>
<p><strong>（A）</strong>可以通过递归解决n个数之和。</p>
<ul>
<li>考虑将n数之和降低为一个数加上n-1数之和</li>
<li>分化为二数之和</li>
<li>target = target - nums[i]来调用nSum（）方法。递归</li>
<li>注意列表的拼接。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nSum</span><span class="params">(nums, target, n, result, results)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(nums) &lt; n <span class="keyword">or</span> n &lt; <span class="number">2</span> <span class="keyword">or</span> n * nums[<span class="number">0</span>] &gt; target <span class="keyword">or</span> n * nums[<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                begin, end = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> begin &lt; end:</span><br><span class="line">                    sums = nums[begin] + nums[end]</span><br><span class="line">                    <span class="keyword">if</span> sums &lt; target:</span><br><span class="line">                        begin += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sums &gt; target:</span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        plet  = [nums[begin], nums[end]]</span><br><span class="line">                        results.append(result + plet)</span><br><span class="line">                        <span class="keyword">while</span> begin &lt; end <span class="keyword">and</span> nums[begin] == plet[<span class="number">0</span>]: begin += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> begin &lt; end <span class="keyword">and</span> nums[end] == plet[<span class="number">1</span>]: end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - n + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">or</span> (nums[i] + (n<span class="number">-1</span>)*nums[len(nums)<span class="number">-1</span>]&lt;target):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> n * nums[i] &gt; target:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> n * nums[i] == target <span class="keyword">and</span> i + n - <span class="number">1</span> &lt; len(nums) <span class="keyword">and</span> nums[i+n<span class="number">-1</span>] == nums[i]:</span><br><span class="line">                        plet = [nums[i]] * n</span><br><span class="line">                        results.append(result + plet)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    nSum(nums[i + <span class="number">1</span>:], target - nums[i], n - <span class="number">1</span>, result + [nums[i]], results)</span><br><span class="line">        results = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        nSum(nums, target, <span class="number">4</span>, [], results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<h4 id="20-有效的括号（D）"><a href="#20-有效的括号（D）" class="headerlink" title="20. 有效的括号（D）"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a>（D）</h4><p>分析：字符串问题，很好实现。</p>
<p>第一种，利用replace直接替换。不需要考虑其他位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'()'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'[]'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>,<span class="string">""</span>).replace(<span class="string">'[]'</span>,<span class="string">""</span>).replace(<span class="string">'&#123;&#125;'</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>第二种，利用堆栈的方式，匹配之后用pop删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">'('</span>,<span class="string">'&#123;'</span>,<span class="string">'['</span>]:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> (char == <span class="string">')'</span>) <span class="keyword">and</span> (stack[len(stack)<span class="number">-1</span>]==<span class="string">'('</span>):</span><br><span class="line">                stack.pop()</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">elif</span> (char == <span class="string">']'</span>) <span class="keyword">and</span> (stack[len(stack)<span class="number">-1</span>]==<span class="string">'['</span>):</span><br><span class="line">                stack.pop()</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">elif</span> (char == <span class="string">'&#125;'</span>) <span class="keyword">and</span> (stack[len(stack)<span class="number">-1</span>]==<span class="string">'&#123;'</span>):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="22-括号生成（B）（暂）"><a href="#22-括号生成（B）（暂）" class="headerlink" title="22. 括号生成（B）（暂）"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a>（B）（暂）</h4><p>分析：跟20题逻辑相逆。</p>
<p>方法1：暴力法，生成所有括号序列，再判断是否有效。数目够就匹配（）是否是对应的。如果，出现）在前，直接返回结果。正好相等时，判断返回True。然后添加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(A = [])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">""</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">'('</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">')'</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(A)</span>:</span></span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> C <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> C == <span class="string">'('</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>方法二？<strong>（A）</strong>：递归生成有效序列。方法二为什么就递归了。知识漏洞！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(S = <span class="string">''</span>,left = <span class="number">0</span>, right = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(S) == <span class="number">2</span> * n:</span><br><span class="line">                ans.append(S)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                backtrack(S+<span class="string">'('</span>, left+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(S+<span class="string">')'</span>, left, right+<span class="number">1</span>)     <span class="comment">#取出一个值后，为什么再次递归。</span></span><br><span class="line">        ans = []</span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Crist">
            
              <p class="site-author-name" itemprop="name">Crist</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qingxuanmingye" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://leetcode-cn.com/qing-xuan-ming-ye/" target="_blank" title="LeetCode">
                      
                        <i class="fa fa-fw fa-leetcode"></i>LeetCode</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crist</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">����ȫվ��15.2k��</span>
</div>-->




        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客总量<i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      访问总量<i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://www.wenjunjiang.win/css/gitment.css">
        <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  undefined
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
