<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-回溯算法]]></title>
    <url>%2F2019%2F05%2F01%2Fleetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[菜 中 46. 全排列（C）47. 全排列 II（C-） 危 37. 解数独（S-）51. N皇后（A）52. N皇后 II（A） 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 解题关键： 出口 通常规律把出口语句放在递归函数的第一行。 递归函数的参数 这个参数是随着每一次的递归操作而发生改变的。而回溯法很关键的一点就是：如果当前操作行不通，如何回溯到上一步操作。 递归函数的处理过程 如果当前递归过程的处理参数符合要求，则执行相关赋值或其它操作，然后转入下一次递归，如果下一次递归不能找到出口，则把之前相关赋值或其它操作重置为初始状态。 37. 解数独（A+）分析：考虑两种编程概念，约束编程和回溯法。 没填一个空单元格判断3个条件。如果，不满足回溯到上一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: def solveSudoku(self, board: List[List[str]]) -&gt; None: """ Do not return anything, modify board in-place instead. """ self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == ".": return row, col return -1, -1 def solve(self): row, col = self.findUnassigned() #no unassigned position is found, puzzle solved if row == -1 and col == -1: return True for num in ["1","2","3","4","5","6","7","8","9"]: if self.isSafe(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = "." return False def isSafe(self, row, col, ch): boxrow = row - row%3 boxcol = col - col%3 if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch): return True return False def checkrow(self, row, ch): for col in range(9): if self.board[row][col] == ch: return False return True def checkcol(self, col, ch): for row in range(9): if self.board[row][col] == ch: return False return True def checksquare(self, row, col, ch): for r in range(row, row+3): for c in range(col, col+3): if self.board[r][c] == ch: return False return True 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def solveSudoku(self, board: List[List[str]]) -&gt; None: """ Do not return anything, modify board in-place instead. """ # 把所有没填数字的位置找到 all_points = [] for i in range(9): for j in range(9): if board[i][j] == ".": all_points.append([i, j]) # check函数是为了检查是否在point位置k是合适的 def check(point, k): row_i = point[0] col_j = point[1] for i in range(9): # 检查 行 if i != row_i and board[i][col_j] == k: return False # 检查 列 if i != col_j and board[row_i][i] == k: return False # 检查块 for i in range(row_i//3*3 , row_i//3*3+3): for j in range(col_j//3*3, col_j//3*3+3): if i != row_i and j != col_j and board[i][j] == k: return False return True def backtrack(i): # 回溯终止条件 if i == len(all_points): return True for j in range(1, 10): # 检查是否合适 if check(all_points[i],str(j)): # 合适就把位置改过来 board[all_points[i][0]][all_points[i][1]] = str(j) if backtrack(i+1): # 回溯下一个点 return True board[all_points[i][0]][all_points[i][1]] = "."# 不成功把原来改回来 return False backtrack(0) python2版本，最快代码。应该是用了哈希 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution(object): def solveSudoku(self, board): """ :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. """ self.board = board self.val = self.PossibleVals() self.Solver() def PossibleVals(self): a = "123456789" d, val = &#123;&#125;, &#123;&#125; for i in xrange(9): for j in xrange(9): ele = self.board[i][j] if ele != ".": d[("r", i)] = d.get(("r", i), []) + [ele] d[("c", j)] = d.get(("c", j), []) + [ele] d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele] else: val[(i,j)] = [] for (i,j) in val.keys(): inval = d.get(("r",i),[])+d.get(("c",j),[])+d.get((i/3,j/3),[]) val[(i,j)] = [n for n in a if n not in inval ] return val def Solver(self): if len(self.val)==0: return True kee = min(self.val.keys(), key=lambda x: len(self.val[x])) nums = self.val[kee] for n in nums: update = &#123;kee:self.val[kee]&#125; if self.ValidOne(n, kee, update): # valid choice if self.Solver(): # keep solving return True self.undo(kee, update) # invalid choice or didn't solve it =&gt; undo return False def ValidOne(self, n, kee, update): self.board[kee[0]][kee[1]] = n del self.val[kee] i, j = kee for ind in self.val.keys(): if n in self.val[ind]: if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3): update[ind] = n self.val[ind].remove(n) if len(self.val[ind])==0: return False return True def undo(self, kee, update): self.board[kee[0]][kee[1]]="." for k in update: if k not in self.val: self.val[k]= update[k] else: self.val[k].append(update[k]) return None 46. 全排列（C）分析：整体就是简单的递归思想。 12345678class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) &lt;= 1: return [nums] res = [] for i, num in enumerate(nums): for r in self.permute(nums[:i] + nums[i + 1:]): res.append([num] + r) return res 47. 全排列 II（C-）分析：根据上题稍微变动一下，加一个条件去重即可 12345678910class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) &lt;= 1: return [nums] res = [] for i, num in enumerate(nums): for r in self.permuteUnique(nums[:i] + nums[i + 1:]): if [num]+r not in res: res.append([num] + r) return res 回溯法常规写法 1234567891011121314class Solution: def dfs(self, nums, path, res): if not nums: res.append(path) for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i-1]: continue self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res) def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] self.dfs(nums, [], res) return res 51. N皇后（A）分析：回溯法经典问题。思路需要梳理清楚。主要学习了两种方式。一种递归方式，另一种非递归方式。最优的方法应该是位排序。利用二进制的特性进行排序。在后一题有详解。 回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 在现实中，有很多问题往往需要我们把其所有可能穷举出来，然后从中找出满足某种要求的可能或最优的情况，从而得到整个问题的解。回溯算法就是解决这种问题的“通用算法”，有“万能算法”之称。N皇后问题在N增大时就是这样一个解空间很大的问题，所以比较适合用这种方法求解。这也是N皇后问题的传统解法，很经典。 把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置，这样便可以把问题的空间规模压缩为一维O(N)，在判断是否冲突时也很简单，首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了，其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。至于斜线冲突，通过观察可以发现所有在斜线上冲突的皇后的位置都有规律即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 第一种递归方式。python 1234567891011121314151617181920212223242526272829class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: res = list() board = [["." for col in range(n)] for row in range(n)] self._dfs(0, n, board, res) return res def _can_place(self, n, board, row, col): for r in range(row): if board[r][col] == 'Q': return False if col + row - r &lt; n and board[r][col + row - r] == 'Q': return False if col - row + r &gt;= 0 and board[r][col - row + r] == 'Q': return False return True def _dfs(self, row, n, board, res): if row == n: res.append(list(map(lambda r: "".join(r), board))) return for col in range(n): if not self._can_place(n, board, row, col): continue board[row][col] = 'Q' self._dfs(row + 1, n, board, res) board[row][col] = '.' cpp 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; board(n, string(n, '.')); dfs(0, n, board, res); return res; &#125;private: void dfs(int row, int n, vector&lt;string&gt;&amp; board, vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123; if (row == n)&#123; res.push_back(board); return; &#125; for (int col = 0; col &lt; n; ++col)&#123; if (can_place(board, n, row, col)) &#123; board[row][col] = 'Q'; dfs(row + 1, n, board, res); board[row][col] = '.'; &#125; &#125; &#125; bool can_place(vector&lt;string&gt;&amp; board, int n, int row, int col)&#123; for (int r = 0; r &lt; row; ++r)&#123; if (board[r][col] == 'Q') return false; if (col + row - r &lt; n &amp;&amp; board[r][col + row - r] == 'Q') return false; if (col - row + r &gt;= 0 &amp;&amp; board[r][col - row + r] == 'Q') return false; &#125; return true; &#125;&#125;; python另一种写法 123456789101112131415161718192021222324from itertools import permutationsclass Solution: def __init__(self): self.res = [] self.n = 0 def solveNQueens(self, n: int) -&gt; List[List[str]]: self.n = n for vec in permutations(range(n)): #这步比较关键,排除各种可能的对角线,好好思考一下就懂了 if (n == len(set(vec[i] + i for i in range(n))) == len(set(vec[i]-i for i in range(n)))): self.generate_q(vec) return self.res #拼接需要的输出结果,添加进self.res def generate_q(self,vec): s = '.'*self.n a = [] for i in vec: q = i*"."+'Q'+(self.n-i-1)*'.' a.append(q) self.res.append(a) python一种优化方式。记录冲突的位置。。 1234567891011121314class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: res = [] def dfs(queens, ddiff, ssum): p = len(queens) if p == n: queens = ['.' * i + 'Q' + '.' * (n - 1 - i) for i in queens] res.append(queens) return for q in range(n): if q in queens or p - q in ddiff or p + q in ssum: continue dfs(queens + [q], ddiff + [p - q], ssum + [p + q]) dfs([], [], []) return res 第二种非递归法 cpp 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;int&gt; pos(n, -1); int row = 0; while (row &gt;= 0) &#123; while(++pos[row] &lt; n &amp;&amp; !can_place(pos, row)); if (pos[row] &lt; n) &#123; if (row == n - 1) &#123; add_solution(res, pos); --row; &#125; else &#123; pos[++row] = -1; &#125; &#125; else&#123; --row; &#125; &#125; return res; &#125; private: bool can_place(vector&lt;int&gt;&amp; pos, int row) &#123; for (int r = 0; r &lt; row; ++r) &#123; if (pos[r] == pos[row] || abs(pos[r] - pos[row]) == row - r) &#123; return false; &#125; &#125; return true; &#125;void add_solution(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;int&gt;&amp; pos) &#123; vector&lt;string&gt; board(pos.size(), string(pos.size(), '.')); for (int row = 0; row &lt; pos.size(); ++row) &#123; board[row][pos[row]] = 'Q'; &#125; res.push_back(board);&#125;&#125;; 一行邪教 12345class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: return [['.' * v + 'Q' + '.' * (n - v - 1) for v in c] for c in itertools.permutations(range(n)) if (len(set(i + v for i, v in enumerate(c))) == n) and (len(set(i - v for i, v in enumerate(c))) == n)] 52. N皇后 II（A）分析:有了上一题的基础，做起来还是挺简单的。符合条件的放入列表。 12 方法二：记录不能放置的位置。 1234567891011121314151617181920212223# @author:leacoder # @des: DFS 深度优先 N皇后IIclass Solution: def totalNQueens(self, n: int) -&gt; int: if n &lt; 1 : return [] # self.count = 0 shu = [] # 竖方向是否被攻击 pie = [] # 撇方向是否被攻击 x y 坐标之和固定 x + y na = [] # 捺方向是否被攻击 x y 坐标之差固定 x - y self.DFS(n,shu,pie,na) return self.count def DFS(self,n,shu,pie,na): #深度优先搜索 p = len(shu) # 从 1 -&gt; n if p == n : self.count += 1 #每层有且只能放一个 return for q in range(n): # 看成 x 每层枚举可能的 x if q not in shu and p - q not in na and p + q not in pie: #这一层存在可能位置，向下层搜索 self.DFS(n,shu+[q],pie+[p+q],na+[p-q]) #深度优先搜索 将被攻击的 坐标记录下来 方法三：位运算的表示，应该是最优方法之一。 123456789101112131415161718192021222324252627# @author:leacoder # @des: 位运算 + DFS 深度优先 N皇后class Solution: def totalNQueens(self, n: int) -&gt; int: if n &lt; 1: return [] self.count = 0 self.DFS(n,0,0,0,0) #从第一行开始 由于棋盘第一行没有放任何皇后那么 row 行 cols 列 pie 撇 na 捺 位没有不可放置的 return self.count def DFS(self, n, row, cols, pie, na): if row &gt;= n: #递归终止条件 深度搜索 n 个皇后均已放在棋盘上 self.count += 1 return # col | pie | na (1 表示被攻击, 或了以后 等到本行 所有被攻击位置 ) # ~( col | pie | na ) 0 表示被攻击位 1 表示可放置位 # (( 1&lt;&lt;n ) - 1) 形成 n位全1的二进制 筛子 用于 筛选出 n 位内的有效数据 bits = ( ~( cols | pie | na )) &amp; (( 1&lt;&lt;n ) - 1) while bits: p = bits &amp; (-bits) # 取出最低位的1 也就是最低位可以放置 皇后Q的位置 # row + 1 下移一层 cols | p : p 上放置 Q 后 cols 列方向被攻击位刷新 # (pie | p) &lt;&lt; 1 下一层 pie撇方向被攻击位置刷新 # (na | p) &gt;&gt; 1 下一层 na 捺方向被攻击位置刷新 self.DFS(n , row + 1, cols | p, (pie | p) &lt;&lt; 1, (na | p) &gt;&gt; 1) # 递归处理下一层 bits = bits &amp; (bits - 1) #去掉最低位的 1 （表示这种可能已被探寻） 参看 LeetCode 52. N皇后 II(N-Queens II)]]></content>
      <categories>
        <category>算法专题</category>
        <category>附c++</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-日卡一]]></title>
    <url>%2F2019%2F05%2F01%2Fleetcode-%E6%97%A5%E5%8D%A1%E4%B8%80%2F</url>
    <content type="text"><![CDATA[菜 326. 3的幂（Dx）38. 报数（B-）58. 最后一个单词的长度（D）66. 加一（D+）67. 二进制求和（Dx）69. x 的平方根（Dx） 中 危 总结：本来想捏的软柿子。结果发现，被柿子给捏了。 326. 3的幂（Dx）分析：妙解。用数论的知识：3的幂次的质因子只有3. 输入时int型，正数范围0~2^31. 即最大的数为3^19 = 1162261467 只需要看这个数是否能被n整除即可。 质因子（或质因数）在数论里是指能整除给定正整数的质数。根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。两个没有共同质因子的正整数称为互质。因为1没有质因子，1与任何正整数（包括1本身）都是互质。只有一个质因子的正整数为质数。 123class Solution: def isPowerOfThree(self, n: int) -&gt; bool: return n &gt; 0 and 1162261467 % n == 0 38. 报数（B-）分析：？什么情况，菜鸟难度的题，题意看了半天。我是来虐菜的，不是来被虐的。 123456789101112131415161718class Solution: def countAndSay(self, n: int) -&gt; str: b = '1' #将第一行的1换成字符类型，便于下一行的读出 for i in range(n-1): #(n-1)是因为第一行不需要处理，直接可以读出 a, c, count = b[0], '', 0 #a用来读取上一行的第一个字符，c用来存放读出的内容(char)，count用来统计 for j in b: if a == j: count += 1 else: c += str(count) + a #注意一定要将count转换为字符型，否则两个数就会相加 a = j count = 1 c += str(count) + a b = c return b 58. 最后一个单词的长度（D）分析：蛮简单的一道题，知道长度就可以从后往前遍历了。注意空集存在。 12345678910class Solution: def lengthOfLastWord(self, s: str) -&gt; int: cnt, tail = 0, len(s) - 1 while tail &gt;= 0 and s[tail] == ' ': #去掉末尾空格，再计数。 tail -= 1 while tail &gt;= 0 and s[tail] != ' ': cnt += 1 tail -= 1 return cnt 66. 加一（D+）分析：短小不错的一道题。 精简版，把数列直接拼接成数字，加一之后再转化为数组。 1234class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: num = str(int(''.join([str(a) for a in digits])) + 1) return [int(i) for i in num] 常规做法 1234567891011121314151617class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: digits.reverse() i = 0 flag = 1 while i &lt; len(digits): if digits[i] + flag == 10: digits[i] = 0 flag = 1 else: digits[i] += flag flag = 0 i += 1 if flag == 1: digits.append(1) digits.reverse() return digits 67. 二进制求和（Dx）巧妙的做法 123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a,2) + int(b,2))[2:] 69. x 的平方根（Dx）牛顿迭代法。求平方的方式。 12345678class Solution: def mySqrt(self, x: int) -&gt; int: if x &lt;= 1: return x r = x while r &gt; x / r: r = (r + x / r) // 2 return int(r)]]></content>
      <categories>
        <category>软柿子专场</category>
      </categories>
      <tags>
        <tag>巧解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-数组一]]></title>
    <url>%2F2019%2F04%2F28%2Fleetcode-%E6%95%B0%E7%BB%84%E4%B8%80%2F</url>
    <content type="text"><![CDATA[菜 35. 搜索插入位置（D-） 中 31. 下一个排列（B+）33. 搜索旋转排序数组（B-）34. 在排序数组中查找元素的第一个和最后一个位置（C）39. 组合总和（A-中二） 40. 组合总和 II（A-） 危 40. 组合总和 II（A-） 总结：本来以为数组题很简单，结果碰到好多问题。引出回溯法，和堆排序。做个专题练习一下。任重道远啊，差的太多了。 31. 下一个排列（B+）分析：一道数组题竟然卡了好久。为什么没有思路呢。关键在于，题意理解，还有细化问题。倒叙从小到大，比较。找到前一个大于后一个，这时交换。再从后往前遍历，确保交换的是最小一个大于i-1的数。然后将i-1之后的所有数从小到大排序。也就是倒序。 转换思维一时间没有转换过来。感觉又误入歧途了。 123456789101112131415class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ for i in range(len(nums)-1, -1, -1): if i-1 &gt;=0 and nums[i] &gt; nums[i-1]: for j in reversed(range(i,len(nums))): if nums[j] &gt; nums[i-1]: nums[i-1], nums[j] = nums[j], nums[i-1] break nums[i:] = nums[i:][::-1] break else: nums = nums.reverse() 第二种。 1234567891011121314class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ for i in range(len(nums)-1, 0, -1): if nums[i] &gt; nums[i-1]: for j in range(len(nums)-1, i-1, -1): if nums[j] &gt; nums[i-1]: nums[j], nums[i-1] = nums[i-1], nums[j] nums[i:] = list(reversed(nums[i:])) return #稍微有点问题，题干说不返回return for i in range(len(nums)//2): #优化只遍历一半，第一个与最后一个交换。 nums[i], nums[-i-1] = nums[-i-1], nums[i] 33. 搜索旋转排序数组（B-）分析：注意要求！你的算法时间复杂度必须是 O(log n) 级别。想到二分法。 先膜拜一下大神的代码 在用 for..in.. 迭代对象时，如果对象没有实现 __iter__ __next__ 迭代器协议，Python的解释器就会去寻找__getitem__ 来迭代对象，如果连__getitem__ 都没有定义，这解释器就会报对象不是迭代器的错误. 实例调用__class__属性时会指向该实例对应的类，然后可以再去调用其它类属性，毕竟类属性还是由类调用会比较好 bisect 其目的在于查找该数值将会插入的位置并返回，而不会插入。 bisect_left 和 bisect_right 函数，该函数用入处理将会插入重复数值的情况，返回将会插入的位置： 12345class Solution: def search(self, nums: List[int], target: int) -&gt; int: self.__class__.__getitem__ = lambda self, m: not(target &lt;nums[0] &lt;= nums[m] or nums[0] &lt;= nums[m] &lt; target or nums[m] &lt; target &lt;= nums[-1]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 第二种 一看到题目要求时间复杂度O(log n) 级别，就应该想到应该是用二分法了。但这题难就难在它并不是一个严格意义上的递增序列，而是两段递增序列组成的。那第一步就应该先用二分法找出分界点。然后对两段用二分法查找出index。相当于用了两次二分法 1234567891011121314151617181920212223242526272829303132333435class Solution: def search(self, nums: List[int], target: int) -&gt; int: #先找到两个第二个升序数组的第一项的 l = 0 r = len(nums) - 1 while l &lt; r: mid = (l + r) // 2 if nums[mid] &gt; nums[r]: l = mid + 1 else: r = mid pol = l ans = self.binary_search(target, nums[:pol]) if ans == -1: ans = self.binary_search(target, nums[pol:]) if ans != -1: ans += len(nums[:pol]) return ans # 二分查找index值函数 def binary_search(self, target, nums): index = -1 l = 0 r = len(nums) - 1 while l &lt;= r: mid = (l+r)//2 if nums[mid] &lt; target: l = mid + 1 elif nums[mid] &gt; target: r = mid - 1 else: index = mid break return index 第三种。直接对target位置进行细分比较。 1234567891011121314151617181920212223242526class Solution: def search(self, nums: List[int], target: int) -&gt; int: l = 0 r = len(nums) - 1 if len(nums) == 0: return -1 while l &lt;= r: m = (l+r)//2 if target == nums[m]: return m elif target == nums[r]: return r elif target == nums[l]: return l else: if nums[m] &lt; nums[r]: if target &gt; nums[m] and target &lt; nums[r]: l = m + 1 else: r = m - 1 else: if target &lt; nums[m] and target &gt; nums[l]: r = m - 1 else: l = m + 1 return -1 34. 在排序数组中查找元素的第一个和最后一个位置（C）分析：你的算法时间复杂度必须是 O(log n) 级别。 经过上一题的洗礼，这道题就显得简单很多了。先二分，找到元素。然后，往前往后循环找到第一个，和最后一个位置。 123456789101112131415161718192021class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: l = 0 r = len(nums) - 1 while l &lt;= r: mid = l + (r-l) // 2 if nums[mid] &lt; target: l = mid + 1 continue if nums[mid] &gt; target: r = mid -1 continue if nums[mid] == target: l = mid r = mid while l &gt; 0 and nums[l-1] == nums[l]: l = l - 1 while r &lt; len(nums)-1 and nums[r] == nums[r+1]: r = r + 1 return [l,r] return [-1, -1] 35. 搜索插入位置（D-）分析：很简单的一道题。二分法并没有快反而变慢了，大概是用例问题。 12345678class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if target in nums: return nums.index(target) else: nums.append(target) nums.sort() return nums.index(target) 二分法 12345678910111213class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: low = 0 high = len(nums) - 1 while low &lt;= high: mid = (low + high) // 2 if nums[mid] == target: return mid if nums[mid] &lt; target: low = mid + 1 else: high = mid - 1 return low 39. 组合总和（A-）中二分析：想用dp做但是感觉不太对。看了别人的答案，觉得步骤很巧妙。这种自迭代加上过滤，匿名函数综合运用。有点厉害。 123456789101112class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: if target == 0: return [[]] elif not candidates or target &lt; min(candidates): return [] res = [] for i in candidates: # 以下过滤器可避免出现排列不同的重复答案且免排序，x&gt;=i和x&lt;=i都行 for j in self.combinationSum(list(filter(lambda x: x &lt;= i, candidates)), target - i): res.append([i] + j) return res filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 第二种。 分支界限法，使用递归函数做到自然剪枝 12345678910111213class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: mylist = [] for i in range(len(candidates)): if target - candidates[i] == 0: mylist.append([candidates[i]]) elif target - candidates[i] &gt; 0: result = self.combinationSum(candidates[i:], target - candidates[i]) if result: for ll in result: ll.insert(0, candidates[i]) mylist += result return mylist 第三种 123456789101112131415161718class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: ans = [] cand = sorted(candidates) def dfs(remain, stack): if remain == 0: ans.append(stack) return for i in cand: if i &gt; remain: break if stack and stack[-1] &gt; i:#这个条件为了答案不重复 continue else: dfs(remain - i, stack + [i]) dfs(target, []) return ans 40. 组合总和 II（A-）分析：和上一题差不多的方法。 回溯法。不是很清楚。明天开个专题。训练一下。答案贴出来，暂且不表。 1234567891011class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: return self.dfs(candidates, target, [], []) def dfs(self, candidates, target, tmp, res): if sum(tmp) == target and sorted(tmp) not in res: res.append(sorted(tmp)) elif sum(tmp) &lt; target: for i in range(len(candidates)): self.dfs(candidates[i + 1:], target, tmp + candidates[i:i + 1], res) return res 第二种。用时短了不少。 12345678910111213141516class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: candidates.sort() len_nums = len(candidates) self.X = [] self.func(0,target,[],candidates,len_nums) return self.X def func(self,index,target,x,nums,len_nums): if target==0: self.X.append(x[:]) for i in range(index, len_nums): # 去重,如【1，1，7】---&gt;【1，7】 if i &gt; index and nums[i]==nums[i-1]: continue if target - nums[i]&gt;=0: self.func(i+1,target-nums[i],x+[nums[i]],nums,len_nums) 41. 缺失的第一个正数（B+）分析： 注意：你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 （1）首先把数组内，范围在 ( 0, n ] 元素x，放到nums[x - 1]，类似桶排序中的找位置。（2）放好之后，进行遍历，找第一个 i + 1 != nums[i]，返回 i + 1，就是结果，如果没有就返回 n + 1。 （3）所以，最小的正整数很重要，如果是第一个没出现的数，就不能这样做了。 桶排序~ 1234567891011121314151617class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: n = len(nums) i = 0 while i &lt; n: if nums[i] &gt;= 1 and nums[i] &lt;= n and nums[i] != i + 1: # nums[i] != i + 1 如果相等或者是本身就没必要替换了，避免死循环 if nums[nums[i] - 1] == nums[i]: # 获取当前位置的数据，减去1是为了得到 在list要插入的位置 i += 1 else: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] else: i += 1 for i in range(1, n + 1): if i != nums[i - 1]: return i return n + 1 第二种。取巧，不过是不是不满足常数空间。 1234567891011121314class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: if not nums: return 1 min_,max_ = min(nums), max(nums) if min_ &gt;1: return 1 else: for i in range(1, max_): if i not in nums: return i return max(1,max_+1) 第三种 ~~ 二。plus 12]]></content>
      <categories>
        <category>需二刷</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-排序一]]></title>
    <url>%2F2019%2F04%2F27%2Fleetcode-%E6%8E%92%E5%BA%8F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[菜 1030. 距离顺序排列矩阵单元格（C+） 中 148. 排序链表（B+）324. 摆动排序 II（C+）75. 颜色分类（C） 危 710. 黑名单中的随机数（A-） 总结：今天的效率还可以。不过，又出现钻牛角尖的情况。简单的问题卡了好久。好在最后迎刃而解。有时候需要暂时搁置，效率优先。 1030. 距离顺序排列矩阵单元格（C+）分析：看了一下别人的思路，大致就是广度遍历，深度遍历。题意很好理解。就是构建矩阵，然后根据原点求距离排序。 矩阵用遍历，原点距离用abs（），排序用sorted。优答：使用了lambda感觉简明不少。 12345678910111213class Solution: def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -&gt; List[List[int]]: def distance(p1,p2): return int(abs(p1[0]-p2[0])+abs(p1[1]-p2[1])) dic = [] for i in range(R): for j in range(C): dic.append([distance([i,j],[r0,c0]),[i,j]]) dic = sorted(dic,key=(lambda x:x[0])) for i in range(len(dic)): dic[i] = dic[i][1] return dic 扩展： sorted用法。与sort区别，不影响结构。 sorted返回一个有序的副本，并且类型总是列表。 sort对原列表进行排序，无返回值。 sort/sorted方法还有两个可选参数：key和reverse key在使用时必须提供一个排序过程总调用的函数： reverse实现降序排序，需要提供一个布尔值：True为倒序排列，False为正序排列 12345678&gt;&gt;&gt; f = [&#123;'name':'abc','age':20&#125;,&#123;'name':'def','age':30&#125;,&#123;'name':'ghi','age':25&#125;] #列表中的元素为字典 &gt;&gt;&gt; def age(s): return s['age'] &gt;&gt;&gt; ff = sorted(f,key = age) #自定义函数按列表f中字典的age从小到大排序 [&#123;'age': 20, 'name': 'abc'&#125;, &#123;'age': 25, 'name': 'ghi'&#125;, &#123;'age': 30, 'name': 'def'&#125;] &gt;&gt;&gt; f2 = sorted(f,key = lambda x:x['age']) #如果觉得上面定义一个函数代码不美观，可以用lambda的形式来定义函数,效果同上 148. 排序链表（B+）分析：应该算是很经典的题了吧。一开始想的很简单。后来发现不对，没那么容易。简单的讲就是归并的思想。先把所有链表都分开，然后排序，再拼接。排序时使用了快慢针。快针分链表时计数，慢针来记录中间指针位置。然后从首中开始向后比较。 递归归并问题卡了我1个多小时。就是想不通，为什么分开之后排序了。终于灵光一现。先分化到底端。然后排序，然后往回找。想通之后，发现就是最基础的归并。 1342》13，42》1，3 2，4》13， 24》1234 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution: def sortList(self, head): """ 主要是使用归并的思路 先分再合 :type head: ListNode :rtype: ListNode """ if head is None: return None return self.minute(head) def minute(self, head): """ 这个方法主要是实现分的操作 分的过程用快慢指针实现 :param head: :return: """ if head.next is None: return head quick, slow, temp = head, head, head while quick is not None and quick.next is not None: temp = slow slow = slow.next quick = quick.next.next temp.next = None # 这一步就是将整个链表从中间分开 失去这一步 后面将无限循环 i = self.minute(head) j = self.minute(slow) return self.Combined(i, j) def Combined(self, i, j): """ 这个方法主要实现合的操作 合的过程就是从i 和 j开始比较 就是从开头和中间开始比较 将两个相比小的排在head后 最后返回head即可 :param i:ListNode :param j:ListNode :return: """ TempNode = ListNode(0) temp = TempNode while i is not None and j is not None: if i.val &lt;= j.val: temp.next = i i = i.next else: temp.next = j j = j.next temp = temp.next if i is not None: temp.next = i if j is not None: temp.next = j return TempNode.next 324. 摆动排序 II（C+）分析：题意简单，但是思考出最优解还是需要细心和耐心的。参考答案，很棒~直接贴出来。 来自StefanPochmann 先对数组排序，分为大数部分和小数部分，再穿插排序。 注意顺序，例如[1，2，4，4，4，6]这个数组，通过降序穿插得到[4,6,2,4,1,4]。 如果顺序排列，则会得到[1,4,2,4,4,6]不满足要求。 这里是因为我们想尽量将小数部分的最大数放在边上，这样只用靠近一个大数部分的最大数。 12345678class Solution: def wiggleSort(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ nums.sort() half = len(nums[::2]) nums[::2], nums[1::2] = nums[:half][::-1],nums[half:][::-1] 75. 颜色分类（C）分析：题意，0，1，2排序。不可以使用sort。 要求：一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 思考仅使用常数空间的一趟扫描算法！ 0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？ 1234567891011121314151617181920class Solution: def sortColors(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ n = len(nums) i = 0 j = n - 1 #取末尾位置,计数往前添加. while i &lt;= j: if nums[i] == 0: nums.pop(i) nums.insert(0,0) i += 1 elif nums[i] == 2: nums.pop(i) nums.insert(j,2) j -= 1 else: i += 1 710. 黑名单中的随机数（A-）分析：感觉无从下手~直接借鉴思路。关键点在于黑名单的映射分类. 思路： 黑名单长度为s，我们从[0, N-s)中取随机值，这个随机值有可能在黑名单中，怎么办？ [0, N-s)内的元素，如果有i个在黑名单中，那么在[N-s, N)中，必定有i个元素不在黑名单中 对[0, N-s)中的黑名单元素和[N-s, N)中不在黑名单中的元素做映射m，必定可以一一对应，怎么对应倒是无所谓 从[0, N-s)中取随机值r，如果r不在黑名单中，直接返回；如果r在黑名单中，则m[r]一定不在黑名单，返回m[r] 1234567891011121314151617181920from random import randint #生成随机整数.有界限.class Solution: def __init__(self, N, blacklist): self.s = N - len(blacklist) b_lt_s = &#123;i for i in blacklist if i &lt; self.s&#125; # 小于s的黑名单元素集合 w_gt_s = &#123;i for i in range(self.s, N)&#125; - set(blacklist) # 大于s的非黑名单元素集合 self.m = &#123;k: v for k,v in zip(b_lt_s, w_gt_s)&#125; # 做映射，使用zip方便一点 def pick(self): """ :rtype: int """ r = randint(0, self.s-1) return r if r not in self.m else self.m[r]]]></content>
      <categories>
        <category>例行打卡</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcodede_队列]]></title>
    <url>%2F2019%2F04%2F22%2Fleetcodede-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[菜 933（B+） 中 621（A-） 、622（C+） 、641（C+） 危 862（A+） 个人总结：队列的题普遍综合性，理解题意就需要花费一定时间。队列是先进先出。有几道都是自定义构造类，实现功能。还是比较锻炼代码基础的。逻辑性还是不好，代码构建时有一些心浮气躁。需要沉下心，慢慢努力。 额外扩展：collections模块的Counter类 933. 最近的请求次数（B）分析：蛤？看题看了三遍，也没读懂要求到底是什么。不是出题人表达能力欠佳，要不就是我理解欠佳。暂且归于后者吧。看了评论知道了题意。如下： 123456789/*法1：其实这题很简单的，用队列的enqueue和dequeue做很简洁（队列用C语言做要啰嗦点）*//*比如输入是[&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;] [[],[1],[100],[3001],[3002]]第一组是(RecentCounter, [])这个意思我觉得是创立一个RecentCounter型的指针并返回，就如这个函数RecentCounter* recentCounterCreate() 第二组是(ping, [1])调用了ping函数，就是这个int recentCounterPing(RecentCounter* obj, int t) ，1时刻和它之前的1-3000时刻之内都应记录好，其实应该是从0开始递增下去的吧，1-3000到1内的负数不用考虑，所以返回值是1；第三组是(ping, [100])，(100 - 3000, 100)这个范围之内的值都应记录起来，就是要包括第二组的(ping, [1])，所以返回值是2；第四组是(ping, [3001])，(3001 - 3000, 3001)这个范围之内，也就是包括了第二组的(ping, [1])和第三组的(ping, [100])，返回值是3；第五组是(ping, [3002])，(3002 - 3000, 3002)这个范围之内，也就是包括了第三组的(ping, [100])和第四组的(ping, [3001])，第二组的(ping, [1])不在范围内，舍掉，此时返回值是3； 12345678910111213141516class RecentCounter: def __init__(self): self.pinglist=[] self.minindex=0 def ping(self, t: int) -&gt; int: self.pinglist.append(t) while t &gt; self.pinglist[self.minindex] + 3000: self.minindex += 1 return len(self.pinglist) - self.minindex# Your RecentCounter object will be instantiated and called as such:# obj = RecentCounter()# param_1 = obj.ping(t) 621. 任务调度器（A-）分析：CPU调度，一开始就被这标题吓唬住了。了解题意后，也没有什么好的想法。看答案，基本都是一个路子。找到一个计算公式。 (count[25] - 1) * (n + 1) + maxCount 公式详解： 假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1 要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount 公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度 12345678class Solution: def leastInterval(self, tasks: List[str], n: int) -&gt; int: count = collections.Counter(tasks) most = count.most_common()[0][1] #most_common()返回一个TopN列表。如果n没有被指定，则返回所有元素。当多个元素计数值相同时，排列是无确定顺序的。 num_most = len([i for i, v in count.items() if v == most]) time = (most - 1) * (n + 1) + num_most return max(time, len(tasks)) 扩展：collections模块的Counter类Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。 参考：http://www.pythoner.com/205.html 第二种方法，基本上区别不大。 1234567891011121314class Solution: def leastInterval(self, tasks: List[str], n: int) -&gt; int: output = [0]*26 for i in tasks: output[ord(i)-ord('A')] = output[ord(i)-ord('A')]+1 #返回ASCII值 count = 0 len_o = 0 max_o = max(output) for i in output: if i==max_o: count = count+1 return max(len(tasks),(max_o-1)*(n+1)+count) ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。 622. 设计循环队列（C）分析：构建类，设计循环队列。很好理解，也算是第一次见这种题型。构建循环队列可以使用数组或者是链表。 MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 循环队列关键点在于avail = (self._front + self._size ) % len(self._data)第一个数位置变动，如果大于循环数组长度，就可以在队列前面添加元素。其他“%”皆是如此。 12345678910111213141516171819202122232425262728293031323334353637383940class MyCircularQueue(object): def __init__(self, k): self._data = [None] * k # 数据 self._size = 0 # 目前储存的个数 self._front = 0 # 第一个数的位置 def enQueue(self, value): if self.isFull(): return False avail = (self._front + self._size ) % len(self._data) # （第一个数的位置 + 目前储存的个数） % 循环数组长度 self._data[avail] = value self._size += 1 return True def deQueue(self): if self.isEmpty()： return False answer = self._data[self._front] self._data[self._front] = None self._front = (self._front + 1) % len(self._data) # （第一个数的位置 + 1） % 循环数组长度 self._size -= 1 return True def Front(self): if self.isEmpty(): return -1 return self._data[self._front] def Rear(self): if self.isEmpty(): return -1 return self._data[(self._front + self._size - 1) % len(self._data)] # （第一个数的位置 + 目前储存的个数 - 1 ） % 循环数组长度 def isEmpty(self): return self._size == 0 def isFull(self): return self._size == len(self._data) 641. 设计循环双端队列（C）分析：跟前一题基本类似。加了一个双端要求。题中要求不可以使用内置的双端队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class MyCircularDeque: def __init__(self, k): """ Initialize your data structure here. Set the size of the deque to be k. :type k: int """ self.queue = [] self.size = k def insertFront(self, value): """ Adds an item at the front of Deque. Return true if the operation is successful. :type value: int :rtype: bool """ if not self.isFull(): self.queue.insert(0,value) return True else: return False def insertLast(self, value): """ Adds an item at the rear of Deque. Return true if the operation is successful. :type value: int :rtype: bool """ if not self.isFull(): self.queue.append(value) return True else: return False def deleteFront(self): """ Deletes an item from the front of Deque. Return true if the operation is successful. :rtype: bool """ if not self.isEmpty(): self.queue.pop(0) return True else: return False def deleteLast(self): """ Deletes an item from the rear of Deque. Return true if the operation is successful. :rtype: bool """ if not self.isEmpty(): self.queue.pop() return True else: return False def getFront(self): """ Get the front item from the deque. :rtype: int """ if self.isEmpty(): return -1 else: return self.queue[0] def getRear(self): """ Get the last item from the deque. :rtype: int """ if self.isEmpty(): return -1 else: return self.queue[-1] def isEmpty(self): """ Checks whether the circular deque is empty or not. :rtype: bool """ return len(self.queue) == 0 def isFull(self): """ Checks whether the circular deque is full or not. :rtype: bool """ return len(self.queue) == self.size 第二种。是同622一样的做法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class MyCircularDeque: def __init__(self, k: 'int'): self.a = [None] * k # internal buffer self.k = k # capacity - max number of elements that deque can hold self.sz = 0 # current size self.b = k - 1 # points to current 'back' element self.f = 0 # points to current 'front' element def prev_idx(self, i): if i == 0: return self.k - 1 else: return i - 1 def next_idx(self, i): return (i + 1) % self.k def insertFront(self, v: 'int') -&gt; 'bool': if self.sz == self.k: return False self.f = self.prev_idx(self.f) self.a[self.f] = v self.sz += 1 return True def insertLast(self, v: 'int') -&gt; 'bool': if self.sz == self.k: return False self.b = self.next_idx(self.b) self.a[self.b] = v self.sz += 1 return True def deleteFront(self) -&gt; 'bool': if self.sz == 0: return False self.f = self.next_idx(self.f) self.sz -= 1 return True def deleteLast(self) -&gt; 'bool': if self.sz == 0: return False self.b = self.prev_idx(self.b) self.sz -= 1 return True def getFront(self) -&gt; 'int': if self.sz == 0: return -1 return self.a[self.f] def getRear(self) -&gt; 'int': if self.sz == 0: return -1 return self.a[self.b] def isEmpty(self) -&gt; 'bol': return self.sz == 0 def isFull(self) -&gt; 'bool': return self.sz == self.k 862. 和至少为 K 的最短子数组（A+）分析：结合了队列和动态规划。由于题中给了 （1 &lt;= K）所以，必须要保证，dp 后一个值减去前一个值，而且是必须大于0才是有效的。从双端队列左侧出队，来寻求最短的字数组是精华所在。 123456789101112131415161718192021222324import collectionsclass Solution: def shortestSubarray(self, A: List[int], K: int) -&gt; int: n, dp = len(A), [0] # 初始化dp[i] = A[0]+A[1]+...+A[i-1] for v in A: dp.append(dp[-1] + v) queue, res = collections.deque(), n + 1 # 初始化双端队列、结果变量 for i in range(n+1): while queue and dp[i] &lt;= dp[queue[-1]]: #因为K &gt;= 1 queue.pop() # 出队, 删除不符合的 while queue and dp[i] - dp[queue[0]] &gt;= K: #满足题意。 res = min(res, i - queue.popleft()) # 从双端队列左边出队，并更新最短距离。 queue.append(i) # 入队 return res if res &lt; n + 1 else -1 #返回最优解，限制不可能超过列表元素。if __name__ == '__main__': solu = Solution() A, K = [2, -1, 2], 3 print(solu.shortestSubarray(A, K))]]></content>
      <categories>
        <category>每日打卡</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode（栈）]]></title>
    <url>%2F2019%2F04%2F20%2Fleetcode%20%E6%A0%88%2F</url>
    <content type="text"><![CDATA[菜 682(E) 中 71(C-) 、394(C+) 危 42(B+) 、84(A) 栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。 小练总结：栈的题相对来说比较简单，需要注意的问题就是模型转化跟栈结合时需要细心一些。实际问题转化为算法时，逻辑上的判断至关重要。 682. 棒球比赛（E）分析：栈初试身手。选了一道简单难度的题。嗯，果然很简单。读清题意，解答很容易的。栈最后位，表示就是用队列的[-1] 123456789101112131415class Solution: def calPoints(self, ops: List[str]) -&gt; int: points = [] i = 0 while i &lt; len(ops): if ops[i] == 'C': points.pop() elif ops[i] == '+': points.append(points[-1] + points[-2]) elif ops[i] == 'D': points.append(points[-1] * 2) else: points.append(int(ops[i])) i += 1 return sum(points) 71. 简化路径（C-）分析：本质上还是一道简单的栈表示。题意理解上稍微复杂一点。如果不熟悉Linux路径表示，需要细心看一下。..删除的是前面出现的路径。整体思路就是分段，去空，判断，构建栈。最后别忘了拼接。 1234567891011121314151617class Solution: def simplifyPath(self, path: str) -&gt; str: l = path.split('/') l = [i for i in l if i] stack = [] while l: c = l.pop(0) if c == '.': continue elif c == '..': if stack: stack.pop(-1) else: stack.append(c) return '/'+'/'.join(stack) 394. 字符串解码（C+）分析：题意容易理解。关键点在于，数字和字母构建双重栈。如果没有数字添加默认1，最后依次匹配相乘。关键点在于，字符拼接时注意翻转。因为栈后进先出。 123456789101112131415161718192021222324252627class Solution: def decodeString(self, s: str) -&gt; str: result = '' stack = []#模拟栈 for i in s: if i != ']': stack.append(i) else: temp1 = []#存字母 while stack[-1] != "[": temp1.append(stack.pop()) temp1_list = list(temp1) stack.pop()#去除[ temp2 = []#存数字 if len(stack)!=0: while stack[-1] in "0123456789": #做循环是为了防止高位数出现 temp2.append(stack.pop()) if len(stack)==0: break if temp2 == []: temp2= ['1'] stack.append(eval("".join(temp2[::-1]))*"".join(temp1[::-1]))#先反转列表形成字符串，然后相乘，添加到stack for i in stack: result += i return result 遇事不决用正则。正则用好了，超级容易实现，然鹅！这道题考察栈。 12345class Solution(object): def decodeString(self, s): while '[' in s: s = re.sub(r"(\d+)\[(\w+)\]",lambda m:int(m.group(1))*m.group(2),s) return s 42. 接雨水（B+）分析：hard难度，就有点意思了。感觉更多的是，找到规律。两边分别遍历一下，墙和水被加了两次，再减去墙。最后减去整体面积。 12345678910class Solution: def trap(self, height: List[int]) -&gt; int: ans = 0 h1 = 0 h2 = 0 for i in range(len(height)): h1 = max(h1,height[i]) h2 = max(h2,height[-i-1]) ans = ans + h1 + h2 -height[i] return ans - len(height)*h1 84. 柱状图中最大的矩形（A）分析：感觉许久未逢的几何生疏感，想了一阵才缕清算法思路，虽然对步骤还有点违和感。 算法书写不难，不过这个思路的构建还是需要学习一下的。关键点在于，右侧高于左侧，放入栈中。低于左侧，就开始计算面积。判断，左右边界，求面积。是i中的高，还是栈中的高，直接影响面积。最后加个0是收尾计算。 1234567891011class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: heights.append(0) #控制边界做最后收尾验算 stack = [-1] res = 0 for i in range(len(heights)): while stack and heights[stack[-1]]&gt;heights[i]: #如果栈中圆柱高于新圆柱 s = stack.pop() #i&lt;i-1.右边界为i-1出栈。 res = max(res,(i-stack[-1]-1)*heights[s]) stack.append(i) return res]]></content>
      <categories>
        <category>日常打卡</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode（脑筋急转弯）]]></title>
    <url>%2F2019%2F04%2F19%2Fleetcode%20%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%2F</url>
    <content type="text"><![CDATA[菜 292(E) 中 319(D) 777(B+) 危 今天就算是娱乐专场了。三道脑筋急转弯。 加餐：zip函数（） 292. Nim游戏（E）分析：额。一开始有点懵，这道题要考什么啊。转弯转在哪里啊。想到了4这个数，加个判断就完成了。 123456class Solution: def canWinNim(self, n: int) -&gt; bool: if n % 4 == 0: return False else: return True 319. 灯泡开关（D）分析：这道题，有点意思。需要考虑到开关状态跟因子数相关。 （1）第i轮时，被切换的灯泡位置是i的倍数。（2）由（1）得出，对于第p个灯泡来说，只有其第“因子”轮才会切换，若其有q个因子，则最终被切换q次。因为初始状态是关闭状态，那么因子数是奇数的灯泡最终是亮着的。（3）只有平方数的因子个数不是成对出现，举例：4=1*4,2*2，其因子是1,2,4。（4）那么题目最终转化为1~n里平方数的个数，进而转化为对n开平方根，向下取整即可。 123class Solution: def bulbSwitch(self, n: int) -&gt; int: return math.floor(n ** 0.5) 777. 在LR字符串中交换相邻字符（B+）L只能跨越X左移，R只能跨越X又移，LR相互之间不可以移动 用两个计数单位分别记录，LX和XR XL和RX。一个正一个负，来比较抵消。 需要注意的是，使用到了zip()函数，扩展在下面。 12345678910111213141516171819202122class Solution: def canTransform(self, start: str, end: str) -&gt; bool: # left move l right move r end_has_l = 0 start_has_r = 0 for s, e in zip(start, end): #zip打包成元组（取最短的） if s == e: continue elif end_has_l and s == "L" and e == "X": # start can move this l to left end_has_l -= 1 elif start_has_r and s == "X" and e == "R": # start has r to move right start_has_r -= 1 elif e == "L": end_has_l += 1 elif s == "R": start_has_r += 1 continue else: return False return start_has_r == end_has_l == 0 zip()函数的使用 a = [1,2,3] b = [4,5,6] c = [4,5,6,7,8] zipped = zip(a,b) # 打包为元组的列表[(1, 4), (2, 5), (3, 6)] zip(a,c) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] zip(zipped) # 与 zip 相反，zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)] 12345678910&gt;&gt;&gt;nums = [&apos;flower&apos;,&apos;flow&apos;,&apos;flight&apos;]&gt;&gt;&gt;for i in zip(*nums):&gt;&gt;&gt; print(i)&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;(&apos;f&apos;, &apos;f&apos;, &apos;f&apos;)&gt;&gt;&gt;(&apos;l&apos;, &apos;l&apos;, &apos;l&apos;)&gt;&gt;&gt;(&apos;o&apos;, &apos;o&apos;, &apos;i&apos;)&gt;&gt;&gt;(&apos;w&apos;, &apos;w&apos;, &apos;g&apos;) &gt;&gt;&gt;]]></content>
      <categories>
        <category>每日打卡</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法梳理]]></title>
    <url>%2F2019%2F04%2F18%2FKMP%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[刷LeetCode算法题的时候，碰到了这个KMP。觉得还有点意思。相对来说还是有点难度，就做个笔记梳理一下。 KMP算法则可以将时间复杂度下降到O(m+n),和O(m*n)相比明显下降。 A，B 》 j，i 不等 为0 A，C 》 j，i 不等为0 一直到 A，A 》 j，i 相等记作1.然后同时进一位。B，B 》 j，i 相等 前位置加1 。C ， D不等，往前推。。A，D也不等，记作0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def KMP_algorithm(string, substring): ''' KMP字符串匹配的主函数 若存在字串返回字串在字符串中开始的位置下标，或者返回-1 ''' pnext = gen_pnext(substring) n = len(string) m = len(substring) i, j = 0, 0 while (i&lt;n) and (j&lt;m): if (string[i]==substring[j]): i += 1 j += 1 elif (j!=0): j = pnext[j-1] else: i += 1 if (j == m): return i-j else: return -1 def gen_pnext(substring): """ 构造临时数组pnext """ index, m = 0, len(substring) pnext = [0]*m i = 1 while i &lt; m: if (substring[i] == substring[index]): pnext[i] = index + 1 index += 1 i += 1 elif (index!=0): index = pnext[index-1] else: pnext[i] = 0 i += 1 return pnextif __name__ == "__main__": string = 'abcxabcdabcdabcy' substring = 'abcdabcy' out = KMP_algorithm(string, substring) print(out) 和主字符串对比时，如果不同，看前一位pnext值对应的字母作为分隔线。为零，就是将整个字符串都后移。 参考文档：b站视频很不错 python代码实现 阮一峰KMP]]></content>
      <categories>
        <category>算法梳理</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode（25~29）]]></title>
    <url>%2F2019%2F04%2F18%2Fleetcode%EF%BC%8825-29%EF%BC%89%2F</url>
    <content type="text"><![CDATA[菜：26（D），27（D=），28（A+/E） 中：29（B+） 死：25（B） 今日总结： 25. k个一组翻转链表（B）分析：久违的链表题，虽然是hard难度，但是并没有需要特别在意的地方。对给定的值进行分情况讨论，翻转链表的方式也是经常使用的。链表整合时的方法还是要多熟悉一下。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: dummy = jump = ListNode(0) dummy.next = r = l = head while True: count = 0 while r and count &lt; k: #用r来定位翻转范围 r = r.next count += 1 if count == k: pre, cur = r, l for _ in range(k): cur.next, cur, pre = pre, cur.next, cur jump.next, jump, l = pre, l, r #初始l的位置，然后将翻转后的链表转出。 else: return dummy.next 26. 删除排序数组中的重复项（D）分析：双指针的用法如果是第一次接触。还是觉得蛮有趣的。很好理解，慢指针记录当前不同元素个数，快指针对比寻找非重复元素（此题就是比较相邻即可），当找到非重复的赋值给慢指针对应位置即可。 这个题的引用法，还是挺有趣的。返回int。输出list。需要更改nums 1234567891011class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 length = 1 #length默认nums[0]不需要变化。 for i in range(len(nums)-1): if nums[i] != nums[i+1]: nums[length] = nums[i+1] length = length + 1 return length 27. 移除元素（D-）分析：上同，没什么变化。 12345678910class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: if len(nums) == 0: return 0 length = 0 for i in range(len(nums)): if nums[i] != val: nums[length] = nums[i] length += 1 return length 28. 实现strStr()（A+/E）分析：还是比较有争议的一道题，涉及是否使用内置函数。如果，单纯算法角度。应该使用KMP算法。难度升高到hard。不管怎样学习一下，KMP算法。内置函数方法直接用find。太简单就省略了。 123456class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: for i in range(0, len(haystack) - len(needle) + 1): if haystack[i:i+len(needle)] == needle: return i return -1 KMP版本（A+）该算法，会单独整理。 123456789101112131415161718192021222324class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if haystack == None or needle == None: return -1 #generate next array, need O(n) time i, j, m, n = -1, 0, len(haystack), len(needle) next = [-1] * n while j &lt; n - 1: #needle[k] stands for prefix, neelde[j] stands for postfix if i == -1 or needle[i] == needle[j]: i, j = i + 1, j + 1 next[j] = i else: i = next[i] #check through the haystack using next, need O(m) time i = j = 0 while i &lt; m and j &lt; n: if j == -1 or haystack[i] == needle[j]: i, j = i + 1, j + 1 else: j = next[j] if j == n: return i - j return -1 29. 两数相除（B+）分析：注意这道题的要求。不可以使用乘，除，mod运算符。想了一下，大概使用数位运算吧。代码还是不太会实现。借鉴一下。初次使用这种方式，还是给与重视一下。 &lt;&lt; 移位运算符。移位是指二进制。左移一，相当于变大一倍。 123456789101112131415class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: positive = (dividend &lt; 0) is (divisor &lt; 0) #判断符号是否相等。在结果处添加符号。 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: #限定继续迭代分化问题 temp, i = divisor, 1 #由1倍开始计算。 while dividend &gt;= temp: dividend -= temp res += i i &lt;&lt;= 1 #i和temp同时变大一倍。就相当于快速缩小范围。 temp &lt;&lt;= 1 if not positive: #此处判断符号 res = -res return min(max(-2147483648, res), 2147483647)]]></content>
      <categories>
        <category>日常打卡</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode（16，17，18，20，22）]]></title>
    <url>%2F2019%2F04%2F17%2Fleetcode%EF%BC%8816%EF%BC%8C17%EF%BC%8C18%EF%BC%8C20%EF%BC%8C22%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今日总结：做题效果不是很好，出现各种状况。感觉不是很难的题，就是陷入思维误区。还有两道题（18，22），暂且搁置。有点窝火，再努力吧。 16. 最接近的三数之和（C）分析：跟之前的题很相识，一个求和，这个是求近似。直观想法还是老套路，排序，然后遍历，比较。 方法一：排序遍历比较，注意下，近似使用abs求绝对值。 123456789101112131415161718192021class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums.sort() if len(nums)&lt;3: return None gol_ans = nums[0]+nums[1]+nums[2] for i in range(len(nums)-2): j = i+1 k = len(nums)-1 while j&lt;k: cur_ans = nums[i]+nums[j]+nums[k] if cur_ans == target: return cur_ans if abs(cur_ans-target) &lt; abs(gol_ans-target): gol_ans=cur_ans if cur_ans &gt; target: k-=1 else: j+=1 return gol_ans 方法二：优化运算时间，想法就是优先考虑两端情况，最大最小。然后其余情况正常，最后将结果。绝对值排序。选出最优。 12345678910111213141516171819202122class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums.sort() closest = [] length = len(nums) for i, num in enumerate(nums[0:-2]): l,r = i+1, length-1 if num+nums[r]+nums[r-1] &lt; target: closest.append(num+nums[r]+nums[r-1]) elif num+nums[l]+nums[l+1] &gt; target: closest.append(num+nums[l]+nums[l+1]) else: while l&lt;r: closest.append(num+nums[r]+nums[l]) if num+nums[l]+nums[r] &gt; target: r -= 1 elif num+nums[l]+nums[r] &lt; target: l += 1 else: return target closest.sort(key=lambda x:abs(x-target)) return closest[0] 17. 电话号码的字母组合（C）分析：每个数字列出对应字母，先读一个数字放入列表。再依次拼接。 1234567891011121314151617181920class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return [] table = &#123;'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'] &#125; result = [''] for digit in digits: str_list = [] for char in table[digit]: str_list += [x + char for x in result] result = str_list return result 优化后（A）。yield生成器返回结果。学习到了。还有函数构造这个也很巧妙。 12345678910111213141516171819class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: dict = &#123;'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'] &#125; def helper(digits, comb = ''): if len(digits) &gt; 0: for i in dict[digits[0]]: yield from helper(digits[1:], comb + i) else: yield comb return list(helper(digits)) if digits != '' else [] 18. 四数之和（C）（暂）分析：emmm~四数之和来了，首先考虑顺着三数之和的思路，4个指针，固定两个数。两个数往中间逼近。考虑可能存在多种情况，需要加一条判断。双嵌套复杂度太高了，直接借鉴优化代码。 （A）可以通过递归解决n个数之和。 考虑将n数之和降低为一个数加上n-1数之和 分化为二数之和 target = target - nums[i]来调用nSum（）方法。递归 注意列表的拼接。 123456789101112131415161718192021222324252627282930313233class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: def nSum(nums, target, n, result, results): if len(nums) &lt; n or n &lt; 2 or n * nums[0] &gt; target or n * nums[-1] &lt; target: return [] if n == 2: begin, end = 0, len(nums)-1 while begin &lt; end: sums = nums[begin] + nums[end] if sums &lt; target: begin += 1 elif sums &gt; target: end -= 1 else: plet = [nums[begin], nums[end]] results.append(result + plet) while begin &lt; end and nums[begin] == plet[0]: begin += 1 while begin &lt; end and nums[end] == plet[1]: end -= 1 else: for i in range(len(nums) - n + 1): if (i &gt; 0 and nums[i] == nums[i-1]) or (nums[i] + (n-1)*nums[len(nums)-1]&lt;target): continue if n * nums[i] &gt; target: break if n * nums[i] == target and i + n - 1 &lt; len(nums) and nums[i+n-1] == nums[i]: plet = [nums[i]] * n results.append(result + plet) break nSum(nums[i + 1:], target - nums[i], n - 1, result + [nums[i]], results) results = [] nums.sort() nSum(nums, target, 4, [], results) return results 20. 有效的括号（D）分析：字符串问题，很好实现。 第一种，利用replace直接替换。不需要考虑其他位置。 12345678910class Solution: def isValid(self, s: str) -&gt; bool: n = len(s) if n == 0: return True if n % 2 != 0: return False while '()' in s or '[]' in s or '&#123;&#125;' in s: s = s.replace('()',"").replace('[]',"").replace('&#123;&#125;',"") return s == "" 第二种，利用堆栈的方式，匹配之后用pop删除。 12345678910111213141516171819class Solution: def isValid(self, s: str) -&gt; bool: stack = [] for char in s: if char in ['(','&#123;','[']: stack.append(char) elif not stack: return False elif (char == ')') and (stack[len(stack)-1]=='('): stack.pop() elif (char == ']') and (stack[len(stack)-1]=='['): stack.pop() elif (char == '&#125;') and (stack[len(stack)-1]=='&#123;'): stack.pop() else: return False return len(stack) == 0 22. 括号生成（B）（暂）分析：跟20题逻辑相逆。 方法1：暴力法，生成所有括号序列，再判断是否有效。数目够就匹配（）是否是对应的。如果，出现）在前，直接返回结果。正好相等时，判断返回True。然后添加。 1234567891011121314151617181920212223class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: def generate(A = []): if len(A) == 2*n: if valid(A): ans.append("".join(A)) else: A.append('(') generate(A) A.pop() A.append(')') generate(A) A.pop() def valid(A): bal = 0 for C in A: if C == '(': bal += 1 else: bal -= 1 if bal &lt; 0: return False return bal == 0 ans = [] generate() return ans 方法二？（A）：递归生成有效序列。方法二为什么就递归了。知识漏洞！ 12345678910111213class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: def backtrack(S = '',left = 0, right = 0): if len(S) == 2 * n: ans.append(S) return if left &lt; n: backtrack(S+'(', left+1, right) if right &lt; left: backtrack(S+')', left, right+1) #取出一个值后，为什么再次递归。 ans = [] backtrack() return ans]]></content>
      <categories>
        <category>日常打卡</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode日常打卡11~15]]></title>
    <url>%2F2019%2F04%2F16%2Fleetcode%EF%BC%8811~15%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode日常打卡11~1511. 盛最多水的容器分析：比较简单的一道题，面积问题，宽高都很容易理解。暴力法会超时。使用双指针即可。 扩展思考，这道题感觉没什么好挖掘的。变化顶多是坐标尺变换一下。判断时注意一下就好。 123456789101112class Solution: def maxArea(self, height: List[int]) -&gt; int: #双指针 max_area = left = 0 right = len(height) - 1 while left &lt; right: max_area = max(max_area,(right - left)*min(height[left],height[right])) if height[left] &lt;= height[right]: left += 1 else: right -= 1 return max_area 12. 整数转罗马数字分析：实现不难。不过，看到优秀解答。忍不住拷贝下来。发散思路真的很重要。 参考luohaha 方法1：第一种方法，依次取出个十百千位，然后转为字符串 1234567891011121314151617181920212223class Solution: def intToRoman(self, num: int) -&gt; str: from collections import deque roman = &#123;1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'&#125; q = deque() i = 0 while num: num, digit = divmod(num, 10) times = pow(10, i) digit *= times i += 1 if digit in roman: q.appendleft(roman[digit]) elif digit &gt;= 5 * times: q.appendleft(roman[times] * ((digit - 5 * times) // times)) q.appendleft(roman[5 * times]) else: q.appendleft(roman[times] * (digit // times)) return ''.join(q) 第二种方法，题目范围位1-3999，用字典保存个十百千位上可能出现的所有罗马数字，依次取出千百个十位，在字典中找到数字对应的罗马数字即可 123456789101112131415class Solution: def intToRoman(self, num: int) -&gt; str: roman = [ ['', "M", "MM", "MMM"], ['', "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"], ['', "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"], ['', "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"], ] num_l = [1000, 100, 10, 1] roman_num = '' for k, v in enumerate(num_l): roman_num += roman[k][num//v] num %= v return roman_num 第三种解法，将数字依次递减，直到减为0，将减去的数字替换为罗马数字即可 1234567891011class Solution: def intToRoman(self, num: int) -&gt; str: values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] reps = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"] roman_num = '' for i in range(13): while num &gt;= values[i]: num -= values[i] roman_num += reps[i] return roman_num 13. 罗马数字转整数分析：相比上一道题差不多。巧妙一处在于如何处理，满减情况。 1234567891011121314class Solution: def romanToInt(self, s: str) -&gt; int: dic = &#123;"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000&#125; last = 0 now = 0 result = 0 for i in s: now = dic[i] if now &gt; last and last != 0: result = (result - last)+(now-last) else: result += now last = now return result 14. 最长公共前缀分析：本以为只是一道简单的题，发掘出不错方法。学到了。 方法一： 利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀 。 123456789class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return "" s1 = min(strs) s2 = max(strs) for i,x in enumerate(s1): if x != s2[i]: return s2[:i] return s1 2、利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀 1234567891011class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return "" ss = list(map(set, zip(*strs))) res = "" for i, x in enumerate(ss): x = list(x) if len(x) &gt; 1: break res = res + x[0] return res 15. 三数之和分析：先排序，建立列表。建立三数之和，然后判断。注意如果相等，需要往中间逼近。逼近同时注意去掉数字相同情况，减少运算复杂度。 123456789101112131415161718192021222324class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res =[] i = 0 for i in range(len(nums)): if i == 0 or nums[i]&gt;nums[i-1]: l = i+1 r = len(nums)-1 while l &lt; r: s = nums[i] + nums[l] +nums[r] if s ==0: res.append([nums[i],nums[l],nums[r]]) l +=1 r -=1 while l &lt; r and nums[l] == nums[l-1]: l += 1 while r &gt; l and nums[r] == nums[r+1]: r -= 1 elif s&gt;0: r -=1 else : l +=1 return res]]></content>
      <categories>
        <category>日常打卡</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 动态规划]]></title>
    <url>%2F2019%2F04%2F12%2Fleetcode%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划（Dynamic Programming） Those who cannot remember the past are condemned to repeat it. 动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。 三个核心元素：最优子结构、边界、状态转移方程式 多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。 动态规划一般可分为 线性动规，etc:拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等； 区域动规，etc:石子合并， 加分二叉树，统计单词个数，炮兵布阵等； 树形动规，etc:贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等； 背包动规。etc:背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶 同类问题通常有三种方式思考 简单递归 备忘录算法 （优化时间复杂度） 动态规划 （优化时间，空间复杂度） 利用简洁的自底向上的递推方式，实现了时间和空间上的最优化。 缺点局限： 时间复杂度（n*w）空间复杂度（w）当所求单位很多时，需要很多空间。反而不如简单递归（跟w无关）。 LeetCode 选题 菜 53、70、121 中 62、63、322 死 32 、44、174、403 53. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解： 思路：动态规划最简单的应用，max 12345class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: for i in range(1, len(nums)): nums[i]= nums[i] + max(nums[i-1], 0) return max(nums) 70. 爬楼梯思路：正常做法，就是最简单的动态规划。省略代码。 看到一个有趣的。做法二：通过设置缓存区，通过递归法运行时间测试。 1234567891011from functools import lru_cacheclass Solution: @lru_cache(10**8) #设置个缓存 def climbStairs(self, n): if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n - 1) + self.climbStairs(n - 2) 121. 买卖股票的最佳时机思路：很简单的一道题，需要注意的就是取最低点买入。然后在高点卖出。满足，低点在前，高点在后。 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) == 0: return 0 min_ = prices[0] result = 0 for i in range(1, len(prices)): min_ = min(min_, prices[i]) result = max(result, prices[i] - min_) return result 62. 不同路径思路： 这个题其实可以用排列组合的方式来做。 以模拟的[4, 7]的例子,每一条路径： 向右的肯定有6步; 向左的肯定有3步; 问题即为:c(9,3) = (9 8 7) / (1 2 3) = 84 组合数公式：c(m,n) = m! / (n! * (m - n)!) 解法1：python一行式！ 123class Solution: def uniquePaths(self, m, n): return int(math.factorial(m + n - 2) / math.factorial(m -1) / math.factorial(n-1)) 解法2： 12345678910class Solution: def uniquePaths(self, m, n): if m &lt;= 0 or n &lt;= 0: return 0 res = [0 for _ in range(0, n)] res[0] = 1 for i in range(0, m): for j in range(1, n): res[j] += res[j-1] return res[n-1] 解法3： 1234567class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: dp = [[1] * n for _ in range(m)] for i in range(1,m): for j in range(1,n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] 63. 不同路径 II思路：加了障碍物。看了几种做法。 解法1： 12345678910111213141516class solution(object): def uniquePathsWithobstacles(self, obstacleGrid): m,n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] if obstacleGrid[0][0] == 0: dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i != 0: dp[i][j] += dp[i - 1][j] if j != 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1] 解法2：进行优化。利用Python语言特性来减少判断次数。我们遍历的方向是第一行从左到右，然后再第二行从左到右的方式进行的，这样如果把dp全部初始化成了0，那么当计算第一行的时候dp[-1][j]实际上就是最后一行的dp，也就是0.同样的，dp[i][-1]实际上是最后一列的dp，但是还没遍历到过，所以也是0.总之，虽然dp数组在计算第一行和第一列的时候用到了最后一行最后一列的dp数据，但是由于还没有遍历到，那么dp数组实际上是0，所以完全可以省去判断。这种方式对于C++和Java不能进行负数索引的不能用。 1234567891011121314class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] if obstacleGrid[0][0] == 0: dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 0: if i == j == 0: continue else: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1] 322. 零钱兑换思路：参考powcai 的解题代码。一题多解。可以用0/1背包,深度遍历(dfs),广度遍历(bfs) 有时间细化一下，各种解法。 解法1：动态规划 123456789class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [float("inf")] * (amount + 1) dp[0] = 0 for i in range(1,amount + 1): for coin in coins: if i - coin &gt;= 0: dp[i] = min(dp[i], dp[i-coin]+1) return dp[-1] if dp[-1] != float('inf') else -1 解法2：深度遍历dfs 123456789101112131415161718192021222324class Solution: def coinChange(self, coins: 'List[int]', amount: 'int') -&gt; 'int': from collections import defaultdict lookup = defaultdict(int) if amount &lt; 1: return 0 def helper(amount): if amount &lt; 0: return -1 if amount == 0: return 0 if lookup[amount]: return lookup[amount] min_num = 2 ** 31 - 1 for coin in coins: res = helper(amount - coin) # min_num = min(min_num,res + 1) if res &gt;= 0 and res &lt; min_num: min_num = res + 1 lookup[amount] = min_num if min_num != 2 ** 31 - 1 else -1 return lookup[amount] return helper(amount) 解法3:广度遍历bfs 1234567891011121314151617181920212223class Solution: def coinChange(self, coins: 'List[int]', amount: 'int') -&gt; 'int': #广度遍历bfs res = 0 cur = [0] visited = set() coins.sort() while cur: next_time = [] res += 1 for tmp in cur: for coin in coins: sum_num = tmp + coin if sum_num == amount: return res elif sum_num &gt; amount: break elif sum_num &lt; amount and sum_num not in visited: next_time.append(sum_num) visited.add(sum_num) cur = next_time return -1 if amount else 0 解法4：约束 123456789101112131415161718192021class Solution: def coinChange(self, coins: 'List[int]', amount: 'int') -&gt; 'int': self.res = float("inf") n = len(coins) if amount == 0: return 0 coins.sort(reverse=True) if amount &lt; coins[-1]: return -1 def dfs(loc, remain, count): if remain == 0: self.res = min(self.res, count) else: for i in range(loc, n): if coins[i] &lt;= remain &lt; coins[i] * (self.res - count): dfs(i, remain - coins[i], count + 1) for i in range(n): dfs(i, amount, 0) return self.res if self.res != float("inf") else -1 Hard32. 最长有效括号分析：问题并不难。关键在于，运用一个列表暂存，一个列表计数。这个方式真的很不错。还有enumerate函数的运用，用取max方式获取最大子串。 123456789101112131415161718class Solution: def longestValidParentheses(self, s: str) -&gt; int: st, b = [], [0]*len(s) for i, val in enumerate(s): if val == '(': st.append(i) elif st: b[st.pop()], b[i] = 1, 1 #清空，记录 c, mc = 0, 0 for i in b: if i: c += 1 else: mc = max(c, mc) #排除单“括号”，中断后获取最大子串。 c = 0 return max(c, mc) 44. 通配符匹配分析：虽然是hard难度，但理解题意。还是很简单的。关键点在于，“*”和“？”的适配情况。 1234567891011121314151617class Solution: def isMatch(self, s: str, p: str) -&gt; bool: m, n = len(s), len(p) dp = [[bool(0) for _ in range(n+1) ]for _ in range(m+1)] dp[0][0] = bool(1) for i in range(n): if dp[0][i] and p[i] == '*': dp[0][i+1] = bool(1) #动态规划 for i in range(m): for j in range(n): if p[j] == '*': dp[i + 1][j + 1] = dp[i][j+1] or dp[i+1][j] elif p[j] == '?' or s[i] == p[j]: dp[i+1][j+1] = dp[i][j] return dp[m][n] 174. 地下城游戏分析：保证血量&gt;=1.还是经典的动态规划做法，从后往前推。 123456789101112131415class Solution: def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int: # 参考 x, y = len(dungeon), len(dungeon[0]) dp = [[0]*y for _ in range(x)] # 能到达最后在这个位置的最小体力值,&gt;=1 dp[-1][-1] = max(1, 1-dungeon[-1][-1]) for j in range(y-2, -1, -1): # 最后一行 dp[-1][j] = max(1, dp[-1][j+1]-dungeon[-1][j]) for i in range(x-2, -1, -1): dp[i][-1] = max(1, dp[i+1][-1]-dungeon[i][-1]) for j in range(y-2, -1, -1): # 从右到左 for i in range(x-2, -1, -1): # 从下到上 # 找这个位置下边或右边需要的较少体力值 dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-dungeon[i][j]) return dp[0][0] 403. 青蛙过河分析：大概是这几道题中最有难度的一道了。国区的评论区竟然没有python3的答案。看别的程序思路有的用哈希表，有的用回溯法+贪心策略+剪枝。感觉一时半会没有好的思路，暂且存疑吧。等到修炼一段时间，再回顾。贴一下英文原站的答案。 123456789101112131415161718192021222324252627282930class Solution: def canCross(self, stones: List[int]) -&gt; bool: ''' let canCross(stones, i, k) be whether the frog can jump start from position i and frog's previou jump size is k. Then next jump can be either k - 1, k, or k + 1 so canCross(stones, i, k) = canCross(stones, i + k - 1, k - 1) or canCross(stones, i + k, k) or canCross(stones, i + k + 1, k + 1) if i + k - 1 or i + k or i + k + 1 be a stone position, otherwise canCross(stones, i, k) = False if i == stones[-1], the frog already sits on the last stone. Return True. ''' self.memo = &#123;&#125; stonePos = set(stones) return self._canCross_helper(stones, 0, 0, stonePos) def _canCross_helper(self, stones:List[int], i: int, k:int, stonePos:set)-&gt;bool: if (i, k) in self.memo: return self.memo[(i, k)] ans = False if i == stones[-1]: ans = True self.memo[(i, k)] = ans return ans if k - 1 &gt; 0: if i + k - 1 in stonePos: ans = ans or self._canCross_helper(stones, i + k - 1, k - 1, stonePos) if k &gt; 0: if i + k in stonePos: ans = ans or self._canCross_helper(stones, i + k, k, stonePos) if i + k + 1 in stonePos: ans = ans or self._canCross_helper(stones, i + k + 1, k + 1, stonePos) self.memo[(i, k)] = ans return ans]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客初期搭建完成]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%9C%9F%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[经过了三天的时间，博客雏形终于完成了。本应该是很容易解决达成的目标。走了各种弯路，见证了好多项目的兴衰。不得不感慨一句，下次如果再没有收罗足够的信息就开始盲目做。我就是瓜皮。(¦3」∠) 虽然做了很多无用功，功能改来改去。bug大概遇到30多个，感觉就像自己做了一个不大不小的项目。不过也不能说了浪费时间吧。首先磨炼了心性，在无人指导，搜索无门的情况下，自己各种钻牛角尖。如果不是实力不够，我就直接修改底层代码了。 本来还想写个教程。鉴于博客搭建的并没有很满意，加上实在是看的厌烦。暂且搁置吧。 最后特别感谢黎静小姐姐的友情支持。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
